<?xml version="1.0" encoding="UTF-8"?>
<?xml-model href="http://docbook.org/xml/5.1/rng/docbook.rng" schematypens="http://relaxng.org/ns/structure/1.0"?>
<?xml-model href="http://docbook.org/xml/5.1/rng/docbook.rng" type="application/xml" schematypens="http://purl.oclc.org/dsdl/schematron"?>
<book xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" version="5.1">
    <info>
        <title>Jegyzökönyv</title>
        <author>
            <personname>Szilágyi-Czumbil Ede Balázs</personname>
        </author>
    </info>
    <part>
        <title/>
        <chapter>
            <title>Infók</title>
            <para>Neptun kód: CMY9W3</para>
            <para>
                Git repó:<link>https://github.com/edeszilagyi/Prog2</link>
            </para>
            <para>e-mail: <email>ede.szilagyi@yahoo.com</email></para>
        </chapter>
        <chapter>
            <title>0. hét - „Helló, Berners-Lee!</title>
            <sect1>
                <title>Java, C++ összehasonlítás</title>
                <para>Könyvek:C++: Benedek Zoltán, Levendovszky Tihamér Szoftverfejlesztés C++
                    nyelven Java: Nyékyné Dr. Gaizler Judit et al. Java 2 útikalauz programozóknak
                    5.0 I-II</para>
                <para>A Java nyelv teljesen objektum orientált nyelv. Ezzel szemben a C++ lehetőséget ad a generikus programozásra is. 
                    A két programnyelv változó kezelése eltérő. Java esetén minden objektum referencia. Ez azt
                    jelenti, hogy az értéküket közvetlen a referencián keresztül érjük el. Mindkét nyelv támogatja a publikus, privát és statikus objektum kezelést.
                    Fordító szempontjából amíg a C++ kódot elég natívan fordítani, addig a Java-hoz szükség van egy virtuális
                    fordítóra, ami futtatja a kódot. Emiatt nagyobb az eroforrás igénye is.Java-ban nem nagyon kell foglalkozni a memória szeméttel, mivel van automatikus garbage collector, ami
                    üríti azt, míg C++-nál fel kell szabadítani a memóriát
                </para>
            </sect1>
            <sect1>
                <title>Python</title>
                <para>Könyv: Forstner Bertalan, Ekler Péter, Kelényi Imre: Bevezetés a mobilprogramozásba.
                    Gyors prototípus-fejlesztés Python és Java nyelven</para>
                <para>  A Python tulajdonképpen egy szkriptnyelv, de nagyon sok csomagot is és beépített
                    eljárást is tartalmaz, ezért komolyabb alkalmazások megírására és komolyabb problémák
                    megoldására is használható.Más modulokkal is együtt tud működni egy Python komponens. A
                    Python egy nagyon magas szintű programozási nyelv.  Pyton esetén nincs szükség
                    fordítás-ra. A Python interpreter elérhető számos platformon. A Pythont könyű hasznáni,
                    megbízható és jelentős támogatást biztosít hibák javítására. A Pythonban minden adat
                    objektumként szerepel. A rajtuk végzendő műveleteket az objektum típusa határozza meg,
                    amit a rendszer futási idoben határoz meg, így nekünk nem kell megadni. A következő
                    típusok lehetnek: szám, string, tuple, list, dictionary. A számok lehetnek egészek,
                    decimálisak, oktálisak vagy akár hexadecimálisak is. Szöveg típus esetén a szöveget két
                    aposztróf közé írva kell megadni.</para>
            </sect1>
        </chapter>
        <chapter>
            <title>1. hét - „Helló, Arroway!”</title>
            <subtitle>1. hét Az objektumorientált paradigma alapfoglamai. Osztály,
                objektum, példányosítás.</subtitle>
            <sect1>
                <title>OO szemlélet</title>
                <para>A módosított polártranszformációs normális generátor beprogramozása Java nyelven. Mutassunk rá, hogy
                    a mi természetes saját megoldásunk (az algoritmus egyszerre két normálist állít elo, kell egy példánytag, ˝
                    amely a nem visszaadottat tárolja és egy logikai tag, hogy van-e tárolt vagy futtatni kell az algot.) és az
                    OpenJDK, Oracle JDK-ban a Sun által adott OO szervezés ua.!
                    Segédlink: <link>https://arato.inf.unideb.hu/batfai.norbert/UDPROG/deprecated/Prog1_5.pdf</link> (16-22 fólia)</para>
                
                <para>A kód:</para>
                <programlisting>public class PolarGenerator {

	boolean nincsTarolt = true;
	double tarolt;
	
	public PolarGenerator() {
		nincsTarolt = true;
	}
	
	public double kovetkezo() {
		if(nincsTarolt) {
			double u1, u2, v1, v2, w;
			do {
				u1 = Math.random();
				u2 = Math.random();
				
				v1 = 2 * u1 - 1;
				v2 = 2 * u2 - 1;
				
				w = v1 * v1 + v2 * v2;
			} while(w > 1);
			double r = Math.sqrt(-2 * Math.log(w) / w);
			
			tarolt = r * v2;
			
			nincsTarolt = !nincsTarolt;
			return r * v1;
		} else {
			nincsTarolt = !nincsTarolt;
			return tarolt;
		}
	}
	
	public static void main(String[] args) {
		PolarGenerator pg = new PolarGenerator();
		
		for(int i = 0; i &lt; 10; i++) {
			System.out.println(pg.kovetkezo());
		}
	}
}
</programlisting>
                <para>A program kezdésként két változót állít elő. Magát a tárolt számot(double) és
                    egy boolean típusu változót ami tárolja hogy van-e változó.Ezután ellenőrzi hogy
                    van e tárolt változó,ha van akkor generál 2 random számot amivel elvégzi az
                    adott műveletet. Ezt addig folytatja amíg a kapott eredmény kisebb lesz 1nél .
                    Ha a nincs tárolt változó false akkor visszaadja a tárolt változóban lévő
                    értéket. </para>
                <para>Miután futtatuk:</para>
                <para><inlinemediaobject>
                    <imageobject>
                        <imagedata fileref="kepek/oomegold.jpg"/>
                    </imageobject>
                </inlinemediaobject></para>
            </sect1>
            <sect1>
                <title>„Gagyi”:</title>
                <para>Az ismert formális2 „while (x &lt;= t &amp;&amp; x >= t &amp;&amp; t != x);”
                    tesztkérdéstípusra adj a szokásosnál (miszerint x, t az egyik esetben az
                    objektum által hordozott érték, a másikban meg az objektum referenciája)
                    „mélyebb” választ, írj Java példaprogramot mely egyszer végtelen ciklus, más x,
                    t értékekkel meg nem! A példát építsd a JDK Integer.java forrására3 , hogy a
                    128-nál inkluzív objektum példányokat poolozza! </para>
                <para>A JDK forrásán belül, a java/lang/Integer.java forrásban látszik hogy az
                    Integer class-nak van egy alapértelmezett cache-je amiben vannak előre
                    elkészített integer osztálybeli objektumok itt el vannak tárolva a -128tól 127ig
                    terjedő számok hogy segítse a programok gyorsabb működését és jobb
                    memóriahasználatát.<programlisting>public static Integer valueOf(int i) {
if (i >= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high)
return IntegerCache.cache[i + (-IntegerCache.low)];
return new Integer(i);
}</programlisting></para>
                <para>E miatt ha a programunkban a [-128,127] intervallumon kívüli értéket adunk meg
                    akkor az egyenlőség hamis lesz mivel két új obiektum fog létrejönni és emiatt
                    végtelen ciklust kapunk.</para>
                <para>Ha viszont az értékek az intervallumon belül van akkor igaz lesaz
                    egyenlőség.</para>
                <para>a program ami végtelen ciklust ad:</para>
                <programlisting>public class Gagyi {

	public static void main(String[] args) {
		
		
		Integer i = 130;
		Integer j = 130;
		
		System.out.println("i = " + i + " j = " + j);

		while(i &lt;= j &amp;&amp; i >= j &amp;&amp; i != j) {
			
		}	
		
	}
}
</programlisting>
                <para>lefuttatva:</para>
                <para><inlinemediaobject>
                    <imageobject>
                        <imagedata fileref="kepek/gagyimegold1.png"/>
                    </imageobject>
                </inlinemediaobject></para>
                <para>a program ami nem végtelen ciklust ad:</para>
                <programlisting>public class Gagyi {

	public static void main(String[] args) {
		
		Integer i = 10;
		Integer j = 10;
		
		System.out.println("i = " + i + " j = " + j);

		while(i &lt;= j &amp;&amp; i >= j &amp;&amp; i != j) {
			
		}	
		
	}
}
</programlisting>
                <para>lefuttatva:</para>
                <para><inlinemediaobject>
                    <imageobject>
                        <imagedata fileref="kepek/gagyimegold2.png"/>
                    </imageobject>
                </inlinemediaobject></para>
                
            </sect1>
            <sect1>
                <title>Yoda</title>
                <para>Írjunk olyan Java programot, ami java.lang.NullPointerEx-el leáll, ha nem követjük a Yoda
                    conditions-t! <link>https://en.wikipedia.org/wiki/Yoda_conditions</link>
                </para>
                <para>A kód:</para>
                <programlisting>public class Yoda {

	public static void main(String[] args) {
		
		final String str = null;
		
		try {
			if(str.equals("...")) {
				//Do something
			}
			System.out.println("1. Success");

		} catch(Exception e) {
			System.err.println(e.getMessage());
		}

		try {
			if("...".equals(str)) {
				//Do something
			}
			System.out.println("2. Success");

		} catch(Exception e) {
			System.err.println(e.getMessage());
		}
	}
}
</programlisting>
                <para>A Yoda condition olyan programozási stílus ahol a kifejezések fordított
                    sorrendben vannak a tipikus,megszokott sorrendhez képest.</para>
                <para>Az előző programrészlet pont ezt próbálja szemléltetni. amikor elősször
                    próbáljuk ellenőrizni az egyenlőséget NullPointerEx-el leáll mivel megsértettük
                    a Yoda condtition-t (null),de mikor megcseréltük a sorrendet már sikerrel
                    jártunk (Success)</para>
                <para>Lefuttatva:</para>
                <para><inlinemediaobject>
                    <imageobject>
                        <imagedata fileref="kepek/yodamegold.jpg"/>
                    </imageobject>
                </inlinemediaobject></para>
            </sect1>
        </chapter>
        <chapter>
            <title>2. hét - „Helló, Liskov!”</title>
            <subtitle>2. hét Öröklődés, osztályhierarchia. Polimorfizmus,
                metódustúlterhelés. Hatáskörkezelés. A bezárási eszközrendszer,
                láthatósági szintek. Absztrakt osztályok és interfészek.</subtitle>
            <sect1>
                <title>Liskov helyettesítés sértése</title>
                <para>Írjunk olyan OO, leforduló Java és C++ kódcsipetet, amely megsérti a Liskov elvet! Mutassunk rá a
                    megoldásra: jobb OO tervezés.</para>
                <para>C++ kódcsipet amelz megsérti a Liskov elvet: </para>
                <programlisting>// ez a T az LSP-ben
class Madar {
public:
     virtual void repul() {};
};

// ez a két osztály alkotja a "P programot" az LPS-ben
class Program {
public:
     void fgv ( Madar &amp;madar ) {
          madar.repul();
     }
};

// itt jönnek az LSP-s S osztályok
class Sas : public Madar
{};

class Pingvin : public Madar // ezt úgy is lehet/kell olvasni, hogy a pingvin tud repülni
{};

int main ( int argc, char **argv )
{
     Program program;
     Madar madar;
     program.fgv ( madar );

     Sas sas;
     program.fgv ( sas );

     Pingvin pingvin;
     program.fgv ( pingvin ); // sérül az LSP, mert a P::fgv röptetné a Pingvint, ami ugye lehetetlen.

}</programlisting>
                 <para>Így lenne helyes:</para>
                <programlisting>// ez a T az LSP-ben
class Madar {
//public:
//  void repul(){};
};

// ez a két osztály alkotja a "P programot" az LPS-ben
class Program {
public:
     void fgv ( Madar &amp;madar ) {
          // madar.repul(); a madár már nem tud repülni
          // s hiába lesz a leszármazott típusoknak
          // repül metódusa, azt a Madar&amp; madar-ra úgysem lehet hívni
     }
};

// itt jönnek az LSP-s S osztályok
class RepuloMadar : public Madar {
public:
     virtual void repul() {};
};

class Sas : public RepuloMadar
{};

class Pingvin : public Madar // ezt úgy is lehet/kell olvasni, hogy a pingvin tud repülni
{};

int main ( int argc, char **argv )
{
     Program program;
     Madar madar;
     program.fgv ( madar );

     Sas sas;
     program.fgv ( sas );

     Pingvin pingvin;
     program.fgv ( pingvin );

}

</programlisting>
            </sect1>
            <sect1>
                <title>Szülo-gyerek</title>
                <para>Írjunk Szülő-gyerek Java és C++ osztálydefiníciót, amelyben demonstrálni tudjuk, hogy az ősön
                    keresztül csak az ős üzenetei küldhetőek!
                </para>
                <para>Ez a feladat csupán azt demonstrálná, hogy nem lehetséges egy adott szülo referencián keresztül, ami egy ˝
                    gyerek objektumára hivatkozik, meghívni gyermeke egy olyan metódusát amit o maga nem definiált. </para>
                <para>A nem Osök által definiált metódusokhoz nem férhetünk hozzá, hacsak nem ˝ downcastoljuk az adott objektumot a tényleges típusára. 
                    Ez esetben viszont megsértjük az eloz˝ o feladatban ismertetett Liskov-elvet. </para>
                <para>C++-ban:</para>
                <programlisting>#include &lt;iostream>
#include &lt;string>
class Parent
{
public:
    void saySomething()
    {
    std::cout &lt;&lt; "Parent says: BLA BLA BLA\n";
    }
};
class Child : public Parent
{
public:
    void echoSomething(std::string msg)
    {
    std::cout &lt;&lt; msg &lt;&lt; "\n";
    }
};
class App
{
    int main()
    {
        Parent* p = new Parent();
        Parent* p2 = new Child();
        std::cout &lt;&lt; "Invoking method of parent\n";
        p->saySomething();
        std::cout &lt;&lt; "Invoking method of child through parent ref\n";
        p2->echoSomething("This won’t work");
        delete p;
        delete p2;
    }
};
</programlisting>
                <para><inlinemediaobject>
                        <imageobject>
                            <imagedata fileref="kepek/szulo-gyerek-sert.png"/>
                        </imageobject>
                    </inlinemediaobject></para>
                <para>Javában:</para>
                <programlisting>class Parent
{
    public void saySomething()
    {
    System.out.println("Parent says: BLA BLA BLA");
    }
}
class Child extends Parent
{
    public void echoSomething(String msg)
    {
    System.out.println(msg);
    }
}
public class App
{
    public static void main(String[] args)
    {
        Parent p = new Parent();
        Parent p2 = new Child();
        System.out.println("Invoking method of parent");
        p.saySomething();
        System.out.println("Invoking method of child through parent ref");
        p2.echoSomething("This won’t work");
        }
}
</programlisting>
                <para><inlinemediaobject>
                        <imageobject>
                            <imagedata fileref="kepek/szulo-gyerek-sert2.png"/>
                        </imageobject>
                    </inlinemediaobject></para>
            </sect1>
            <sect1>
                <title>Hello, Android!</title>
                <para>Élesszük fel az SMNIST for Humans projektet!
                    <link>https://gitlab.com/nbatfai/smnist/tree/master/forHumans/SMNISTforHumansExp3/app/src/main</link>
                    Apró módosításokat eszközölj benne, pl. színvilág.</para>
                <para><inlinemediaobject>
                        <imageobject>
                            <imagedata fileref="kepek/SMINST.png"/>
                        </imageobject>
                    </inlinemediaobject></para>
                <para>Márcsak a színvilágot kell megváltoztatni a feladat szerint:
                    Ezt megtehetjük a SMNISTSurfaceView.java állományban a megfelelo˝
                    <itemizedlist>
                        <listitem>
                            <para>bgColor</para>
                        </listitem>
                        <listitem>
                            <para>textPaint</para>
                        </listitem>
                        <listitem>
                            <para>msgPaint</para>
                        </listitem>
                        <listitem>
                            <para>dotPaint</para>
                        </listitem>
                        <listitem>
                            <para>borderPaint</para>
                        </listitem>
                        <listitem>
                            <para>fillPaint</para>
                        </listitem>
                    </itemizedlist>
                    s a többi változók értékeinek megváltoztatásával.</para>
                <para><inlinemediaobject>
                        <imageobject>
                            <imagedata fileref="kepek/SMINST2.png"/>
                        </imageobject>
                    </inlinemediaobject></para>
            </sect1>
            
        </chapter>
        <chapter>
            <title>3. hét - „Helló, Mandelbrot!”</title>
            <subtitle>3. hét Modellező eszközök és nyelvek. AZ UML és az UML
                osztálydiagramja.</subtitle>
            <sect1>
                <title>Reverse engineering UML osztálydiagram</title>
                <para>UML osztálydiagram rajzolása az első védési C++ programhoz. Az osztálydiagramot a forrásokból
                    generáljuk (pl. Argo UML, Umbrello, Eclipse UML) Mutassunk rá a kompozíció és aggregáció
                    kapcsolatára a forráskódban és a diagramon, lásd még: <link>https://youtu.be/Td_nlERlEOs</link>.</para>
                <para> <link>https://arato.inf.unideb.hu/batfai.norbert/UDPROG/deprecated/Prog1_6.pdf</link> (28-32 fólia)</para>
                <para>A megoldás forrása:</para>
                <para><inlinemediaobject>
                        <imageobject>
                            <imagedata fileref="kepek/reverse%20engineering%20uml.png"/>
                        </imageobject>
                    </inlinemediaobject></para>
                <para>A feladat megoldása során a Visual Paradigm programot használtam a kódból való uml diagram elkészítésére. Az uml diagrammok lényege hogy egy ábrában megmutassa egy adott program tervezetét. Ez kiválóan
                    használható arra, hogy megtervezzünk egy programot, majd a diagramm alapján elkészítsük annak kódbéli
                    verzióját. Ezt lehet úgy is hogy a terv alapján kézzel megírjuk a kódot vagy az ábra alapján le is lehet
                    generálni a kódot. D</para>
                <para>Ebben a feladatban az LZWBinfa kódból lett elkészítve a diagramm. A diagrammon látható hogy milyen
                    osztályokból épül fel a program és azok között milyen kapcsolat van. Továbbá látható az is hogy az osztályok milyen változókkal és metódusokkal rendelkeznek. Mint látható egy osztály két részre van osztva a
                    diagrammon. A felso részben található a változók listája, az alsó részben pedig a metódusok listája. To- ˝
                    vábbá minden változó és metódus elott látható egy +, - vagy # jel. Ez jelöli azt hogy a hozzáférhet ˝ osége az ˝
                    milyen. A + jelenti a public-ot, a - a private-ot, a # pedig a protected jelzot jelenti.</para>
                
            </sect1>
            <sect1>
                <title>Forward engineering UML osztálydiagram</title>
                <para>UML-ben tervezzünk osztályokat és generáljunk belőle forrást!</para>
                <para>Ebben a feladatban egy UML diagrammból kell kódot készíteni. Az UML diagrammot a Visual Paradigm
                    programmal készítjük el majd utána kódot generálunk belole. Els ˝ onek el kell készíteni az osztályokat és ˝
                    belehelyezni a kívánt változókat és metódusokat. Ha ez megvan akkor be kell jelölni a közöttük lévo˝
                    kapcsolatokat. Ez után már nincs más dolgunk mint elvégezni a kód generálást.</para>
                <para><inlinemediaobject>
                        <imageobject>
                            <imagedata fileref="kepek/UML.png"/>
                        </imageobject>
                    </inlinemediaobject></para>
            </sect1>
            <sect1>
                <title>BPMN</title>
                <para>Rajzoljunk le egy tevékenységet BPMN-ben!</para>
                <para><link>https://arato.inf.unideb.hu/batfai.norbert/UDPROG/deprecated/Prog2_7.pdf</link> (34-47 fólia)</para>
                <para>A BPMN - teljes nevén Business Process Model and Notation - egy olyan fajta modellézt takar ami kiválóan
                    alkalmas arra hogy egy folyamat lépéseit szemléltessünk benne. Be lehet vele mutatni hogy egy adott
                    folyamat során milyen lépési lehetoségek vannak és hogy hová vezethetnek. Kiválóan alkalmas folyamatok ˝
                    megtervezésére és arra hogy a folyamatok minden irányú kimenetelét szemléltessük.</para>
                <para>Megoldás:</para>
                <para><inlinemediaobject>
                        <imageobject>
                            <imagedata fileref="kepek/1.png"/>
                        </imageobject>
                    </inlinemediaobject></para>
                <para>Jelen ábrán egy prog1 labor folyamata látható. A kezdo állapotot a vékony kör jelöli. ˝
                    Ezután a folyamat lépéset a téglalapok jelölik a nyilak pedig a folyamat irányát. A rombusz az elágazásokat jelenti ahonnan a kimeneteltol függően halad tovább a folyamat. A végén pedig a vastag kör a
                    végállapotot jelenti ahol a folyamat végetér.</para>
            </sect1>
        </chapter>
        <chapter>
            <title>4. hét - „Helló, Chomsky!”</title>
            <subtitle>4. hét Objektumorientált programozási nyelvek programnyelvi
                elemei: karakterkészlet, lexikális egységek, kifejezések, utasítások.</subtitle>
            <sect1>
                <title>Encoding</title>
                <para>Fordítsuk le és futtassuk a Javat tanítok könyv MandelbrotHalmazNagyító.java forrását úgy, hogy a
                    fájl nevekben és a forrásokban is meghagyjuk az ékezetes betűket!</para>
                    <para><link>https://www.tankonyvtar.hu/hu/tartalom/tkt/javat-tanitok-javat/adatok.html</link></para>
                <para>A feladat során a MandelbrotHalmazNagyító.java fájlt kellett fordítani de úgy
                    hogy az ékezetes karakterekkel együtt is forduljon. Ez úgy kivitelezheto ha a
                    program fordítása során beadunk egy encoding kapcsolót a  parancssori
                    paraméterek közzé: javac -encoding "ISO-8859-1" MandelbrotIterációk.java
                    MandelbrotHalmazNagyító.java.</para>
                <para>Az encoding kulcsszó segítségével adjuk meg karakterkódolást amely
                    segítségével értelmezni akarjuk a kódot. Jelen helyzetben ez a karakterkészlet
                    az ISO-8859-1. Ez egy szabvány amely tartalmazza az ékezetes karaktereket és így
                    ennek segítségével már m ˝uködni fog a program.</para>
            </sect1>
            <sect1>
                <title>l334d1c4</title>
                <para>Írj olyan OO Java vagy C++ osztályt, amely leet cipherként működik, azaz megvalósítja ezt a betű
                    helyettesítést: <link>https://simple.wikipedia.org/wiki/Leet</link> (Ha ez első részben nem tetted meg, akkor írasd
                    ki és magyarázd meg a használt struktúratömb memóriafoglalását!)</para>
                <para>A leet cipher alapjának írnunk kell egy "ábécét", amibol majd a cipherünk
                    válogatni tud. Ehhez használni tudjuk a fenti linket, ebben találunk pár példát
                    a 1337 "ábécére".</para>
                <programlisting>import java.util.Scanner;

public class leetCipher
{
    public static void main(String[] args)
    {
        Scanner in = new Scanner(System.in);
        String text = in.next();

        for (int i = 0; i &lt; text.length(); i++)
        {
            switch (text.charAt(i))
            {
                case 'a': System.out.print("4"); break;
                case 'b': System.out.print("8"); break;
                case 'c': System.out.print("("); break;
                case 'd': System.out.print("|}"); break;
                case 'e': System.out.print("3"); break;
                case 'f': System.out.print("|="); break;
                case 'g': System.out.print("6"); break;
                case 'h': System.out.print("|-|"); break;
                case 'i': System.out.print("1"); break;
                case 'j': System.out.print("|"); break;
                case 'k': System.out.print("|&lt;"); break;
                case 'l': System.out.print("|_"); break;
                case 'm': System.out.print("(V)"); break;
                case 'n': System.out.print("/\\/"); break;
                case 'o': System.out.print("0"); break;
                case 'p': System.out.print("|D"); break;
                case 'q': System.out.print("9"); break;
                case 'r': System.out.print("|2"); break;
                case 's': System.out.print("$"); break;
                case 't': System.out.print("7"); break;
                case 'u': System.out.print("|_|"); break;
                case 'v': System.out.print("\\/"); break;
                case 'w': System.out.print("\\/\\/"); break;
                case 'x': System.out.print(")("); break;
                case 'y': System.out.print("y"); break;
                case 'z': System.out.print("2"); break;
                default: System.out.print(text.charAt(i)); break;
            }

        }
        System.out.println();
    }
}
</programlisting>
                <para>Lefuttatva:</para>
                <para><inlinemediaobject>
                        <imageobject>
                            <imagedata fileref="kepek/Leet.png"/>
                        </imageobject>
                    </inlinemediaobject></para>
            </sect1>
            <sect1>
                <title>Fullscreen</title>
                <para>Készítsünk egy teljes képernyős Java programot!</para>
                <para>Tipp:<link>https://www.tankonyvtar.hu/en/tartalom/tkt/javat-tanitok-javat/ch03.html#labirintus_jatek</link></para>
                <para>A feladat megoldásához saját egyszerű programkódot használtam ami abból áll,
                    hogy megjelenít a képernyőre különböző gombokat, csúszkákat. A teljes képernyős
                    mód kódját a fullscreen.java  fájlban tudjuk megnézni, a fullscreen metóduson
                    belül:<programlisting>public fullscreen() {
        setUndecorated(true);
        setAlwaysOnTop(true);
        setResizable(false);
        setVisible(true);
        Toolkit tk= Toolkit.getDefaultToolkit();
        
        int x=(int) tk.getScreenSize().getWidth();
        int y=(int) tk.getScreenSize().getHeight();
        
        setSize(x, y);
        initComponents();
    }</programlisting></para>
                <para>Íme a lefutott teljesképernyős program:</para>
                <para><inlinemediaobject>
                        <imageobject>
                            <imagedata fileref="kepek/fullscreen.png"/>
                        </imageobject>
                    </inlinemediaobject></para>
            </sect1>
        </chapter>
        <chapter>
            <title>5. hét - „Helló, Stroustrup!”</title>
            <subtitle>5. hét Objektumorientált programozási nyelvek típusrendszere (pl.:
                Java, C#) és 6. hét Típusok tagjai: mezők, (nevesített) konstansok,
                tulajdonságok, metódusok, események, operátorok, indexelők,
                konstruktorok, destruktorok, beágyazott típusok.Összevonva.</subtitle>
            <sect1>
                <title>Másoló-mozgató szemantika</title>
                <para>Kódcsipeteken (copy és move ctor és assign) keresztül vesd össze a C++11 másoló és a mozgató
                    szemantikáját, a mozgató konstruktort alapozd a mozgató értékadásra!</para>
                <para>A kód:</para>
                <programlisting>#include &lt;iostream>


class IntClass 
{
public:
	int ertek;

	IntClass () //parameter nelkuli alap
	{
		ertek = 0;
		std::cout &lt;&lt; "Paraméter nélküli konstruktor.."	&lt;&lt; std::endl;
	}

	IntClass (int x)//parameteres 
	{
		ertek = x;
		std::cout &lt;&lt; "Paraméteres konstruktor.." &lt;&lt; std::endl;	
	}

	void operator= (const IntClass &amp;t) //egyenlőség
	{
		this->ertek = t.ertek;
		std::cout &lt;&lt; "Egyenlőség operátor (osztály) túlterhelés.." &lt;&lt; std::endl;
	}

	void operator= (int t)
	{
		this->ertek = t;
		std::cout &lt;&lt; "Egyenlőség operátor (int) túlterhelés.." &lt;&lt; std::endl;
	}
				
	IntClass operator+ (const IntClass &amp;t) //összeadás
	{
		IntClass x;
		x.ertek = this->ertek + t.ertek;
		std::cout &lt;&lt; "Összeadas operátor túlterhelés.." &lt;&lt; std::endl;
		return x;
	}

	IntClass operator- (const IntClass &amp;t) //kivonás
	{
		IntClass x;
		x.ertek = this->ertek - t.ertek;
		std::cout &lt;&lt; "Kivonás operátor túlterhelés.." &lt;&lt; std::endl;
		return x;
	}

	IntClass operator* (const IntClass &amp;t) //szorzás
	{
		IntClass x;
		x.ertek = this->ertek * t.ertek;
		std::cout &lt;&lt; "Szorzás operátor túlterheles.." &lt;&lt; std::endl;
		return x;
	}

	IntClass operator/ (const IntClass &amp;t) //osztás
	{
		IntClass x;
		x.ertek = this->ertek / t.ertek;
		std::cout &lt;&lt; "Osztás operátor túlterheles.." &lt;&lt; std::endl;
		return x;
	}

	void operator+= (const IntClass &amp;t) //hozzáad
	{
		this->ertek += t.ertek;
		std::cout &lt;&lt; "+= operátor túlterheles.." &lt;&lt; std::endl;
	}
	
	void operator-= (const IntClass &amp;t) //kivon
	{
		this->ertek -= t.ertek;
		std::cout &lt;&lt; "-= operátor túlterheles.." &lt;&lt; std::endl;
	}

	void operator++ (int) //növel
	{
		ertek++;
		std::cout &lt;&lt; "++ operátor túlterheles.." &lt;&lt; std::endl;
	}

	void operator-- (int) //csökkent
	{
		ertek--;
		std::cout &lt;&lt; "-- operátor túlterheles.." &lt;&lt; std::endl;
	}

	~IntClass()
	{
		std::cout &lt;&lt; "Destruktor.." &lt;&lt; std::endl;
	}

};

int 
main()
{
	IntClass x, y, z = 5;
	x = 10;
	std::cout &lt;&lt; x.ertek &lt;&lt; std::endl;

	x = y;
	std::cout &lt;&lt; x.ertek &lt;&lt; std::endl;

	x = y + z;
	std::cout &lt;&lt; x.ertek &lt;&lt; std::endl;

	x = y - z;
	std::cout &lt;&lt; x.ertek &lt;&lt; std::endl;

	x = y * z;
	std::cout &lt;&lt; x.ertek &lt;&lt; std::endl;

	x = y / z;
	std::cout &lt;&lt; x.ertek &lt;&lt; std::endl;

	x += z;
	std::cout &lt;&lt; x.ertek &lt;&lt; std::endl;

	x -= z;
	std::cout &lt;&lt; x.ertek &lt;&lt; std::endl;

	x++;
	std::cout &lt;&lt; x.ertek &lt;&lt; std::endl;

	x--;
	std::cout &lt;&lt; x.ertek &lt;&lt; std::endl;

	return 0;
}
	</programlisting>
                <para>Lefuttatva:</para>
                <para><inlinemediaobject>
                        <imageobject>
                            <imagedata fileref="kepek/move-copy%20ctor.png"/>
                        </imageobject>
                    </inlinemediaobject></para>
            </sect1>
            <sect1>
                <title>Változó argumentumszámú ctor</title>
                <para>Készítsünk olyan példát, amely egy képet tesz az alábbi projekt Perceptron osztályának bemenetére
                    és a Perceptron ne egy értéket, hanem egy ugyanakkora méretű „képet” adjon vissza. (Lásd még a 4
                    hét/Perceptron osztály feladatot is.)</para>
                <para/>
            </sect1>
            <sect1>
                <title>Összefoglaló</title>
                <para>Az előző 4 feladat egyikéről írj egy 1 oldalas bemutató „”esszé szöveget!</para>
                
                    <para><emphasis role="underline">Másoló-mozgató
                            szemantika</emphasis></para><orderedlist>
                            <listitem>
                                <para><emphasis role="underline"><emphasis role="bold">Másoló
                                            szemantika</emphasis></emphasis><emphasis role="underline">:</emphasis></para>
                            </listitem>
                        </orderedlist><para> Ha van az osztályban dinamikus adattag, akkor
                            alapértelmezésben tiltjuk , míg privátban deklaráljuk a másoló
                            konstruktort és másoló értékadást.Különben alkalmazzuk a “Rule of three”
                            szabályt.</para><para>A Rule of three szabály kimondja, hogy ha
                            dinamikus tagot aggregáló osztályban kell implementálni:</para><itemizedlist>
                            <listitem>
                                <para>Destruktort,</para>
                            </listitem>
                            <listitem>
                                <para>Másoló konstruktort,</para>
                            </listitem>
                            <listitem>
                                <para>Vagy másoló értékadást</para>
                            </listitem>
                        </itemizedlist><para>Akkor nagy valószínűséggel mindhármat implementálni
                            kell.</para><para>Példa Rule of three-re:</para>
                <programlisting>Int(const Int&amp;);
Int(Int&amp;&amp;); //Rule of 5
Int&amp; operator=(const Int&amp;);
Int&amp; operator=(Int&amp;&amp;);
~Int();</programlisting>
                <para>
                    2.<emphasis role="underline"><emphasis role="bold">Mozgató szemantika:</emphasis></emphasis></para>
                <para> C++11-be bekerűlt a mozgató konstruktor, amely alkamazása drasztikusan
                       hatékonyabbá tette a kódokat. A mozgató konstruktor legfontosabb
                       tulajdonsága, hogy a használatával elkerülhető a memória újraelosztása
                       és ugyanannyi memóriát használ mint amennyit az eredeti objektum
                       használt, aminek ideiglenes funkciója van, mivel miután átadta az
                       értéket az új objektumnak törlésre kerül. Ahhoz, hogy alkalmazni tudjuk
                       a mozgató szemantikát, először meg kell oldanunk azt a problémát, hogy
                       az eredeti objektumot hibamentesen töröljük.
                </para>
                <para> Példa:</para>
                <programlisting>#include&lt;bits/stdc++.h> 
int main() 
{ 
	std :: vector &lt;int> vec1 {1, 2, 3, 4, 5}; 
	std :: vector &lt;int> vec2 {6, 6, 6, 6, 6}; 

	
	std :: cout &lt;&lt; "1.vektor elemei :"; 
	for(int i = 0; i &lt; vec1.size(); i++) 
		std :: cout &lt;&lt; " " &lt;&lt; vec1[i]; 
	std :: cout &lt;&lt; "\n"; 
	
	std :: cout &lt;&lt; "2.vektor elemei :"; 
	for(unsigned int i = 0; i &lt; vec2.size(); i++) 
		std :: cout &lt;&lt; " " &lt;&lt; vec2[i]; 
	std :: cout &lt;&lt; "\n\n"; 
	
	// elso 3 elemet az 1.vektorbol move-olja a 2.vektor 1.elemetol 
	std :: move (vec1.begin(), vec1.begin() + 3, vec2.begin()); 
	
	std :: cout &lt;&lt; "2.vektor elemei std::move utan:"; 
	for(unsigned int i = 0; i &lt; vec2.size(); i++) 
		std :: cout &lt;&lt; " " &lt;&lt; vec2[i]; 
	std :: cout &lt;&lt; "\n"; 



	return 0; 
} </programlisting>
             <para>Lefuttatva:</para>
             <para><inlinemediaobject>
                        <imageobject>
                            <imagedata fileref="kepek/asd.png"/>
                        </imageobject>
                    </inlinemediaobject></para>
             <para>
                    <table frame="all">
                        <title>Copy ctor vs Move ctor</title>
                        <tgroup cols="2">
                            <colspec colnum="1" colwidth="1*" colname="Másoló konstruktor"/>
                            <colspec colname="Mozgató konstruktor" colnum="2" colwidth="1*"/>
                            <thead>
                                <row>
                                    <entry>
                                        <para>Másoló konstruktor</para>
                                    </entry>
                                    <entry>
                                        <para>Mozgató konstruktor</para>
                                    </entry>
                                </row>
                            </thead>
                            <tbody>
                                <row>
                                    <entry>
                                        <para>Az argumentum referenciaként a bal oldali értéket
                                            kapja.</para>
                                    </entry>
                                    <entry>
                                        <para>Az argumentum referenciaként a jobb oldali értéket
                                            kapja.</para>
                                    </entry>
                                </row>
                                <row>
                                    <entry>
                                        <para>Új objektumot hoz létre a kapott objektumból az által,
                                            hogy lemásolja az összes értékét egy új memória
                                            címre.</para>
                                    </entry>
                                    <entry>
                                        <para>Új objektumot hoz létre, de ugyanannyi memóriát
                                            használ mint az átadott objektum.</para>
                                    </entry>
                                </row>
                                <row>
                                    <entry>
                                        <para>Nem hatékony, mivel sok memória elosztást használ
                                            működése során az új objektumok létrehozására.A mozgató
                                            konstruktor használata sokkal hatékonyabb.</para>
                                    </entry>
                                    <entry>
                                        <para>Memóriahasználatának nagy részét a kapott objektum
                                            teszi ki, ezért hatékonyabb, mint a másoló
                                            konstruktor.</para>
                                    </entry>
                                </row>
                                <row>
                                    <entry>
                                        <para>Nem változtat semmit a kapott objektumon, ezért a
                                            kapott objektum használható másoló operátor után
                                            is.</para>
                                    </entry>
                                    <entry>
                                        <para>Mivel a mozgató konstruktor a kapott objektum memória
                                            blokkjait használja, ezért a kapott objektum nem
                                            használható mozgató operátor után.</para>
                                    </entry>
                                </row>
                            </tbody>
                        </tgroup>
                    </table>
                </para>
               
            </sect1>
        </chapter>
        <chapter>
            <title>6. hét - „Helló, Gödel!”</title>
            <subtitle>7. hét Interfészek. Kollekciók. és 8. hét Funkcionális nyelvi
                elemek. Lambda kifejezések.Összevonva.</subtitle>
            <sect1>
                <title>STL map érték szerinti rendezése</title>
                <para>Például:<link>https://github.com/nbatfai/future/blob/master/cs/F9F2/fenykard.cpp#L180</link></para>
                <para/>
            </sect1>
            <sect1>
                <title>Alternatív Tabella rendezése</title>
                <para>Mutassuk be a
                        <link>https://progpater.blog.hu/2011/03/11/alternativ_tabella</link> a
                    programban a java.lang Interface Comparable&lt;T> szerepét!</para>
                <para/>
            </sect1>
        </chapter>
        <chapter>
            <title>7. hét - „Helló, !”</title>
            <subtitle>9. hét Adatfolyamok kezelése, streamek és 11. hét I/O,
                állománykezelés. Szerializáció.</subtitle>
            <sect1>
                <title>FUTURE tevékenység editor</title>
                <para>Javítsunk valamit a ActivityEditor.java JavaFX programon!</para>
                <para><link>https://github.com/nbatfai/future/tree/master/cs/F6</link></para>
                <para>Itt láthatjuk működésben az alapot: <link>https://www.twitch.tv/videos/222879467</link></para>
                <para/>
            </sect1>
            <sect1>
                <title>OOCWC Boost ASIO hálózatkezelése</title>
                <para>Mutassunk rá a scanf szerepére és használatára! <link>https://github.com/nbatfai/robocaremulator/blob/master/justine/rcemu/src/carlexer.ll</link></para>
                <para/>
            </sect1>
            <sect1>
                <title>BrainB</title>
                <para>Mutassuk be a Qt slot-signal mechanizmust ebben a projektben: <link>https://github.com/nbatfai/esporttalent-search</link></para>
                <para/>
            </sect1>
        </chapter>
        <chapter>
            <title>8. hét - „Helló, Schwarzenegger!”</title>
            <subtitle>10. hét Kivételkezelés. és 12. hét Reflexió. A fordítást és a
                kódgenerálást támogató nyelvi elemek (annotációk, attribútumok). Összevonva.</subtitle>
            <sect1>
                <title>Port scan</title>
                <para>Mutassunk rá ebben a port szkennelő forrásban a kivételkezelés szerepére!</para>
                <para><link>https://www.tankonyvtar.hu/hu/tartalom/tkt/javat-tanitok-javat/ch01.html#id527287</link></para>
                <para/>
            </sect1>
            <sect1>
                <title>Android Játék</title>
                <para>Írjunk egy egyszerű Androidos „játékot”! Építkezzünk például a 2. hét „Helló, Android!” feladatára!</para>
                <para/>
            </sect1>
        </chapter>
        <chapter>
            <title>9. hét - „Helló, Calvin!”</title>
            <subtitle>13. hét Multiparadigmás nyelvek és 14. hét Programozás
                multiparadigmás nyelveken. Összevonva.</subtitle>
            <sect1>
                <title>MNIST</title>
                <para>Az alap feladat megoldása, +saját kézzel rajzolt képet is ismerjen fel,</para>
                <para><link>https://progpater.blog.hu/2016/11/13/hello_samu_a_tensorflow</link>-bol Háttérként ezt vetítsük le:</para>
                <para><link>https://prezi.com/0u8ncvvoabcr/no-programming-programming/</link></para>
                <para/>
            </sect1>
            <sect1>
                <title>Android telefonra a TF objektum detektálója</title>
                <para>Telepítsük fel, próbáljuk ki!</para>
                <para/>
            </sect1>
        </chapter>
    </part>
</book>
