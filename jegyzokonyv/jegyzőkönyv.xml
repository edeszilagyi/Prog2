<?xml version="1.0" encoding="UTF-8"?>
<?xml-model href="http://docbook.org/xml/5.1/rng/docbook.rng" schematypens="http://relaxng.org/ns/structure/1.0"?>
<?xml-model href="http://docbook.org/xml/5.1/rng/docbook.rng" type="application/xml" schematypens="http://purl.oclc.org/dsdl/schematron"?>
<book xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" version="5.1">
    <info>
        <title>Jegyzökönyv</title>
        <author>
            <personname>Szilágyi-Czumbil Ede Balázs</personname>
        </author>
    </info>
    <part>
        <title/>
        <chapter>
            <title>Infók</title>
            <para>Neptun kód: CMY9W3</para>
            <para>
                Git repó:<link>https://github.com/edeszilagyi/Prog2</link>
            </para>
            <para>e-mail: <email>ede.szilagyi@yahoo.com</email></para>
        </chapter>
        <chapter>
            <title>0. hét - „Helló, Berners-Lee!</title>
            <sect1>
                <title>Java, C++ összehasonlítás</title>
                <para>Könyvek:C++: Benedek Zoltán, Levendovszky Tihamér Szoftverfejlesztés C++
                    nyelven Java: Nyékyné Dr. Gaizler Judit et al. Java 2 útikalauz programozóknak
                    5.0 I-II</para>
                <para>A Java nyelv teljesen objektum orientált nyelv. Ezzel szemben a C++ lehetőséget ad a generikus programozásra is. 
                    A két programnyelv változó kezelése eltérő. Java esetén minden objektum referencia. Ez azt
                    jelenti, hogy az értéküket közvetlen a referencián keresztül érjük el. Mindkét nyelv támogatja a publikus, privát és statikus objektum kezelést.
                    Fordító szempontjából amíg a C++ kódot elég natívan fordítani, addig a Java-hoz szükség van egy virtuális
                    fordítóra, ami futtatja a kódot. Emiatt nagyobb az eroforrás igénye is.Java-ban nem nagyon kell foglalkozni a memória szeméttel, mivel van automatikus garbage collector, ami
                    üríti azt, míg C++-nál fel kell szabadítani a memóriát
                </para>
            </sect1>
            <sect1>
                <title>Python</title>
                <para>Könyv: Forstner Bertalan, Ekler Péter, Kelényi Imre: Bevezetés a mobilprogramozásba.
                    Gyors prototípus-fejlesztés Python és Java nyelven</para>
                <para>  A Python tulajdonképpen egy szkriptnyelv, de nagyon sok csomagot is és beépített
                    eljárást is tartalmaz, ezért komolyabb alkalmazások megírására és komolyabb problémák
                    megoldására is használható.Más modulokkal is együtt tud működni egy Python komponens. A
                    Python egy nagyon magas szintű programozási nyelv.  Pyton esetén nincs szükség
                    fordítás-ra. A Python interpreter elérhető számos platformon. A Pythont könyű hasznáni,
                    megbízható és jelentős támogatást biztosít hibák javítására. A Pythonban minden adat
                    objektumként szerepel. A rajtuk végzendő műveleteket az objektum típusa határozza meg,
                    amit a rendszer futási idoben határoz meg, így nekünk nem kell megadni. A következő
                    típusok lehetnek: szám, string, tuple, list, dictionary. A számok lehetnek egészek,
                    decimálisak, oktálisak vagy akár hexadecimálisak is. Szöveg típus esetén a szöveget két
                    aposztróf közé írva kell megadni.</para>
            </sect1>
        </chapter>
        <chapter>
            <title>1. hét - „Helló, Arroway!”</title>
            <subtitle>1. hét Az objektumorientált paradigma alapfoglamai. Osztály,
                objektum, példányosítás.</subtitle>
            <sect1>
                <title>OO szemlélet</title>
                <para>A módosított polártranszformációs normális generátor beprogramozása Java nyelven. Mutassunk rá, hogy
                    a mi természetes saját megoldásunk (az algoritmus egyszerre két normálist állít elo, kell egy példánytag, ˝
                    amely a nem visszaadottat tárolja és egy logikai tag, hogy van-e tárolt vagy futtatni kell az algot.) és az
                    OpenJDK, Oracle JDK-ban a Sun által adott OO szervezés ua.!
                    Segédlink: <link>https://arato.inf.unideb.hu/batfai.norbert/UDPROG/deprecated/Prog1_5.pdf</link> (16-22 fólia)</para>
                
                <para>A kód:</para>
                <programlisting>public class PolarGenerator {

	boolean nincsTarolt = true;
	double tarolt;
	
	public PolarGenerator() {
		nincsTarolt = true;
	}
	
	public double kovetkezo() {
		if(nincsTarolt) {
			double u1, u2, v1, v2, w;
			do {
				u1 = Math.random();
				u2 = Math.random();
				
				v1 = 2 * u1 - 1;
				v2 = 2 * u2 - 1;
				
				w = v1 * v1 + v2 * v2;
			} while(w > 1);
			double r = Math.sqrt(-2 * Math.log(w) / w);
			
			tarolt = r * v2;
			
			nincsTarolt = !nincsTarolt;
			return r * v1;
		} else {
			nincsTarolt = !nincsTarolt;
			return tarolt;
		}
	}
	
	public static void main(String[] args) {
		PolarGenerator pg = new PolarGenerator();
		
		for(int i = 0; i &lt; 10; i++) {
			System.out.println(pg.kovetkezo());
		}
	}
}
</programlisting>
                <para>A program kezdésként két változót állít elő. Magát a tárolt számot(double) és
                    egy boolean típusu változót ami tárolja hogy van-e változó.Ezután ellenőrzi hogy
                    van e tárolt változó,ha van akkor generál 2 random számot amivel elvégzi az
                    adott műveletet. Ezt addig folytatja amíg a kapott eredmény kisebb lesz 1nél .
                    Ha a nincs tárolt változó false akkor visszaadja a tárolt változóban lévő
                    értéket. </para>
                <para>Miután futtatuk:</para>
                <para><inlinemediaobject>
                    <imageobject>
                        <imagedata fileref="kepek/oomegold.jpg"/>
                    </imageobject>
                </inlinemediaobject></para>
            </sect1>
            <sect1>
                <title>„Gagyi”:</title>
                <para>Az ismert formális2 „while (x &lt;= t &amp;&amp; x >= t &amp;&amp; t != x);”
                    tesztkérdéstípusra adj a szokásosnál (miszerint x, t az egyik esetben az
                    objektum által hordozott érték, a másikban meg az objektum referenciája)
                    „mélyebb” választ, írj Java példaprogramot mely egyszer végtelen ciklus, más x,
                    t értékekkel meg nem! A példát építsd a JDK Integer.java forrására3 , hogy a
                    128-nál inkluzív objektum példányokat poolozza! </para>
                <para>A JDK forrásán belül, a java/lang/Integer.java forrásban látszik hogy az
                    Integer class-nak van egy alapértelmezett cache-je amiben vannak előre
                    elkészített integer osztálybeli objektumok itt el vannak tárolva a -128tól 127ig
                    terjedő számok hogy segítse a programok gyorsabb működését és jobb
                    memóriahasználatát.<programlisting>public static Integer valueOf(int i) {
if (i >= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high)
return IntegerCache.cache[i + (-IntegerCache.low)];
return new Integer(i);
}</programlisting></para>
                <para>E miatt ha a programunkban a [-128,127] intervallumon kívüli értéket adunk meg
                    akkor az egyenlőség hamis lesz mivel két új obiektum fog létrejönni és emiatt
                    végtelen ciklust kapunk.</para>
                <para>Ha viszont az értékek az intervallumon belül van akkor igaz lesaz
                    egyenlőség.</para>
                <para>a program ami végtelen ciklust ad:</para>
                <programlisting>public class Gagyi {

	public static void main(String[] args) {
		
		
		Integer i = 130;
		Integer j = 130;
		
		System.out.println("i = " + i + " j = " + j);

		while(i &lt;= j &amp;&amp; i >= j &amp;&amp; i != j) {
			
		}	
		
	}
}
</programlisting>
                <para>lefuttatva:</para>
                <para><inlinemediaobject>
                    <imageobject>
                        <imagedata fileref="kepek/gagyimegold1.png"/>
                    </imageobject>
                </inlinemediaobject></para>
                <para>a program ami nem végtelen ciklust ad:</para>
                <programlisting>public class Gagyi {

	public static void main(String[] args) {
		
		Integer i = 10;
		Integer j = 10;
		
		System.out.println("i = " + i + " j = " + j);

		while(i &lt;= j &amp;&amp; i >= j &amp;&amp; i != j) {
			
		}	
		
	}
}
</programlisting>
                <para>lefuttatva:</para>
                <para><inlinemediaobject>
                    <imageobject>
                        <imagedata fileref="kepek/gagyimegold2.png"/>
                    </imageobject>
                </inlinemediaobject></para>
                
            </sect1>
            <sect1>
                <title>Yoda</title>
                <para>Írjunk olyan Java programot, ami java.lang.NullPointerEx-el leáll, ha nem követjük a Yoda
                    conditions-t! <link>https://en.wikipedia.org/wiki/Yoda_conditions</link>
                </para>
                <para>A kód:</para>
                <programlisting>public class Yoda {

	public static void main(String[] args) {
		
		final String str = null;
		
		try {
			if(str.equals("...")) {
				//Do something
			}
			System.out.println("1. Success");

		} catch(Exception e) {
			System.err.println(e.getMessage());
		}

		try {
			if("...".equals(str)) {
				//Do something
			}
			System.out.println("2. Success");

		} catch(Exception e) {
			System.err.println(e.getMessage());
		}
	}
}
</programlisting>
                <para>A Yoda condition olyan programozási stílus ahol a kifejezések fordított
                    sorrendben vannak a tipikus,megszokott sorrendhez képest.</para>
                <para>Az előző programrészlet pont ezt próbálja szemléltetni. amikor elősször
                    próbáljuk ellenőrizni az egyenlőséget NullPointerEx-el leáll mivel megsértettük
                    a Yoda condtition-t (null),de mikor megcseréltük a sorrendet már sikerrel
                    jártunk (Success)</para>
                <para>Lefuttatva:</para>
                <para><inlinemediaobject>
                    <imageobject>
                        <imagedata fileref="kepek/yodamegold.jpg"/>
                    </imageobject>
                </inlinemediaobject></para>
            </sect1>
        </chapter>
        <chapter>
            <title>2. hét - „Helló, Liskov!”</title>
            <subtitle>2. hét Öröklődés, osztályhierarchia. Polimorfizmus,
                metódustúlterhelés. Hatáskörkezelés. A bezárási eszközrendszer,
                láthatósági szintek. Absztrakt osztályok és interfészek.</subtitle>
            <sect1>
                <title>Liskov helyettesítés sértése</title>
                <para>Írjunk olyan OO, leforduló Java és C++ kódcsipetet, amely megsérti a Liskov elvet! Mutassunk rá a
                    megoldásra: jobb OO tervezés.</para>
                <para>C++ kódcsipet amelz megsérti a Liskov elvet: </para>
                <programlisting>// ez a T az LSP-ben
class Madar {
public:
     virtual void repul() {};
};

// ez a két osztály alkotja a "P programot" az LPS-ben
class Program {
public:
     void fgv ( Madar &amp;madar ) {
          madar.repul();
     }
};

// itt jönnek az LSP-s S osztályok
class Sas : public Madar
{};

class Pingvin : public Madar // ezt úgy is lehet/kell olvasni, hogy a pingvin tud repülni
{};

int main ( int argc, char **argv )
{
     Program program;
     Madar madar;
     program.fgv ( madar );

     Sas sas;
     program.fgv ( sas );

     Pingvin pingvin;
     program.fgv ( pingvin ); // sérül az LSP, mert a P::fgv röptetné a Pingvint, ami ugye lehetetlen.

}</programlisting>
                 <para>Így lenne helyes:</para>
                <programlisting>// ez a T az LSP-ben
class Madar {
//public:
//  void repul(){};
};

// ez a két osztály alkotja a "P programot" az LPS-ben
class Program {
public:
     void fgv ( Madar &amp;madar ) {
          // madar.repul(); a madár már nem tud repülni
          // s hiába lesz a leszármazott típusoknak
          // repül metódusa, azt a Madar&amp; madar-ra úgysem lehet hívni
     }
};

// itt jönnek az LSP-s S osztályok
class RepuloMadar : public Madar {
public:
     virtual void repul() {};
};

class Sas : public RepuloMadar
{};

class Pingvin : public Madar // ezt úgy is lehet/kell olvasni, hogy a pingvin tud repülni
{};

int main ( int argc, char **argv )
{
     Program program;
     Madar madar;
     program.fgv ( madar );

     Sas sas;
     program.fgv ( sas );

     Pingvin pingvin;
     program.fgv ( pingvin );

}

</programlisting>
            </sect1>
            <sect1>
                <title>Szülo-gyerek</title>
                <para>Írjunk Szülő-gyerek Java és C++ osztálydefiníciót, amelyben demonstrálni tudjuk, hogy az ősön
                    keresztül csak az ős üzenetei küldhetőek!
                </para>
                <para>Ez a feladat csupán azt demonstrálná, hogy nem lehetséges egy adott szülo referencián keresztül, ami egy ˝
                    gyerek objektumára hivatkozik, meghívni gyermeke egy olyan metódusát amit o maga nem definiált. </para>
                <para>A nem Osök által definiált metódusokhoz nem férhetünk hozzá, hacsak nem ˝ downcastoljuk az adott objektumot a tényleges típusára. 
                    Ez esetben viszont megsértjük az eloz˝ o feladatban ismertetett Liskov-elvet. </para>
                <para>C++-ban:</para>
                <programlisting>#include &lt;iostream>
#include &lt;string>
class Parent
{
public:
    void saySomething()
    {
    std::cout &lt;&lt; "Parent says: BLA BLA BLA\n";
    }
};
class Child : public Parent
{
public:
    void echoSomething(std::string msg)
    {
    std::cout &lt;&lt; msg &lt;&lt; "\n";
    }
};
class App
{
    int main()
    {
        Parent* p = new Parent();
        Parent* p2 = new Child();
        std::cout &lt;&lt; "Invoking method of parent\n";
        p->saySomething();
        std::cout &lt;&lt; "Invoking method of child through parent ref\n";
        p2->echoSomething("This won’t work");
        delete p;
        delete p2;
    }
};
</programlisting>
                <para><inlinemediaobject>
                        <imageobject>
                            <imagedata fileref="kepek/szulo-gyerek-sert.png"/>
                        </imageobject>
                    </inlinemediaobject></para>
                <para>Javában:</para>
                <programlisting>class Parent
{
    public void saySomething()
    {
    System.out.println("Parent says: BLA BLA BLA");
    }
}
class Child extends Parent
{
    public void echoSomething(String msg)
    {
    System.out.println(msg);
    }
}
public class App
{
    public static void main(String[] args)
    {
        Parent p = new Parent();
        Parent p2 = new Child();
        System.out.println("Invoking method of parent");
        p.saySomething();
        System.out.println("Invoking method of child through parent ref");
        p2.echoSomething("This won’t work");
        }
}
</programlisting>
                <para><inlinemediaobject>
                        <imageobject>
                            <imagedata fileref="kepek/szulo-gyerek-sert2.png"/>
                        </imageobject>
                    </inlinemediaobject></para>
            </sect1>
            <sect1>
                <title>Hello, Android!</title>
                <para>Élesszük fel az SMNIST for Humans projektet!
                    <link>https://gitlab.com/nbatfai/smnist/tree/master/forHumans/SMNISTforHumansExp3/app/src/main</link>
                    Apró módosításokat eszközölj benne, pl. színvilág.</para>
                <para><inlinemediaobject>
                        <imageobject>
                            <imagedata fileref="kepek/SMINST.png"/>
                        </imageobject>
                    </inlinemediaobject></para>
                <para>Márcsak a színvilágot kell megváltoztatni a feladat szerint:
                    Ezt megtehetjük a SMNISTSurfaceView.java állományban a megfelelo˝
                    <itemizedlist>
                        <listitem>
                            <para>bgColor</para>
                        </listitem>
                        <listitem>
                            <para>textPaint</para>
                        </listitem>
                        <listitem>
                            <para>msgPaint</para>
                        </listitem>
                        <listitem>
                            <para>dotPaint</para>
                        </listitem>
                        <listitem>
                            <para>borderPaint</para>
                        </listitem>
                        <listitem>
                            <para>fillPaint</para>
                        </listitem>
                    </itemizedlist>
                    s a többi változók értékeinek megváltoztatásával.</para>
                <para><inlinemediaobject>
                        <imageobject>
                            <imagedata fileref="kepek/SMINST2.png"/>
                        </imageobject>
                    </inlinemediaobject></para>
            </sect1>
            
        </chapter>
        <chapter>
            <title>3. hét - „Helló, Mandelbrot!”</title>
            <subtitle>3. hét Modellező eszközök és nyelvek. AZ UML és az UML
                osztálydiagramja.</subtitle>
            <sect1>
                <title>Reverse engineering UML osztálydiagram</title>
                <para>UML osztálydiagram rajzolása az első védési C++ programhoz. Az osztálydiagramot a forrásokból
                    generáljuk (pl. Argo UML, Umbrello, Eclipse UML) Mutassunk rá a kompozíció és aggregáció
                    kapcsolatára a forráskódban és a diagramon, lásd még: <link>https://youtu.be/Td_nlERlEOs</link>.</para>
                <para> <link>https://arato.inf.unideb.hu/batfai.norbert/UDPROG/deprecated/Prog1_6.pdf</link> (28-32 fólia)</para>
                <para>A megoldás forrása:</para>
                <para><inlinemediaobject>
                        <imageobject>
                            <imagedata fileref="kepek/reverse%20engineering%20uml.png"/>
                        </imageobject>
                    </inlinemediaobject></para>
                <para>A feladat megoldása során a Visual Paradigm programot használtam a kódból való uml diagram elkészítésére. Az uml diagrammok lényege hogy egy ábrában megmutassa egy adott program tervezetét. Ez kiválóan
                    használható arra, hogy megtervezzünk egy programot, majd a diagramm alapján elkészítsük annak kódbéli
                    verzióját. Ezt lehet úgy is hogy a terv alapján kézzel megírjuk a kódot vagy az ábra alapján le is lehet
                    generálni a kódot. D</para>
                <para>Ebben a feladatban az LZWBinfa kódból lett elkészítve a diagramm. A diagrammon látható hogy milyen
                    osztályokból épül fel a program és azok között milyen kapcsolat van. Továbbá látható az is hogy az osztályok milyen változókkal és metódusokkal rendelkeznek. Mint látható egy osztály két részre van osztva a
                    diagrammon. A felso részben található a változók listája, az alsó részben pedig a metódusok listája. To- ˝
                    vábbá minden változó és metódus elott látható egy +, - vagy # jel. Ez jelöli azt hogy a hozzáférhet ˝ osége az ˝
                    milyen. A + jelenti a public-ot, a - a private-ot, a # pedig a protected jelzot jelenti.</para>
                
            </sect1>
            <sect1>
                <title>Forward engineering UML osztálydiagram</title>
                <para>UML-ben tervezzünk osztályokat és generáljunk belőle forrást!</para>
                <para>Ebben a feladatban egy UML diagrammból kell kódot készíteni. Az UML diagrammot a Visual Paradigm
                    programmal készítjük el majd utána kódot generálunk belole. Els ˝ onek el kell készíteni az osztályokat és ˝
                    belehelyezni a kívánt változókat és metódusokat. Ha ez megvan akkor be kell jelölni a közöttük lévo˝
                    kapcsolatokat. Ez után már nincs más dolgunk mint elvégezni a kód generálást.</para>
                <para><inlinemediaobject>
                        <imageobject>
                            <imagedata fileref="kepek/UML.png"/>
                        </imageobject>
                    </inlinemediaobject></para>
            </sect1>
            <sect1>
                <title>BPMN</title>
                <para>Rajzoljunk le egy tevékenységet BPMN-ben!</para>
                <para><link>https://arato.inf.unideb.hu/batfai.norbert/UDPROG/deprecated/Prog2_7.pdf</link> (34-47 fólia)</para>
                <para>A BPMN - teljes nevén Business Process Model and Notation - egy olyan fajta modellézt takar ami kiválóan
                    alkalmas arra hogy egy folyamat lépéseit szemléltessünk benne. Be lehet vele mutatni hogy egy adott
                    folyamat során milyen lépési lehetoségek vannak és hogy hová vezethetnek. Kiválóan alkalmas folyamatok ˝
                    megtervezésére és arra hogy a folyamatok minden irányú kimenetelét szemléltessük.</para>
                <para>Megoldás:</para>
                <para><inlinemediaobject>
                        <imageobject>
                            <imagedata fileref="kepek/2.png"/>
                        </imageobject>
                    </inlinemediaobject></para>
                <para>Jelen ábrán egy prog1 labor folyamata látható. A kezdo állapotot a vékony kör jelöli. ˝
                    Ezután a folyamat lépéset a téglalapok jelölik a nyilak pedig a folyamat irányát. A rombusz az elágazásokat jelenti ahonnan a kimeneteltol függően halad tovább a folyamat. A végén pedig a vastag kör a
                    végállapotot jelenti ahol a folyamat végetér.</para>
            </sect1>
        </chapter>
        <chapter>
            <title>4. hét - „Helló, Chomsky!”</title>
            <subtitle>4. hét Objektumorientált programozási nyelvek programnyelvi
                elemei: karakterkészlet, lexikális egységek, kifejezések, utasítások.</subtitle>
            <sect1>
                <title>Encoding</title>
                <para>Fordítsuk le és futtassuk a Javat tanítok könyv MandelbrotHalmazNagyító.java forrását úgy, hogy a
                    fájl nevekben és a forrásokban is meghagyjuk az ékezetes betűket!</para>
                    <para><link>https://www.tankonyvtar.hu/hu/tartalom/tkt/javat-tanitok-javat/adatok.html</link></para>
                <para>A feladat során a MandelbrotHalmazNagyító.java fájlt kellett fordítani de úgy
                    hogy az ékezetes karakterekkel együtt is forduljon. Ez úgy kivitelezheto ha a
                    program fordítása során beadunk egy encoding kapcsolót a  parancssori
                    paraméterek közzé: javac -encoding "ISO-8859-2" MandelbrotIterációk.java
                    MandelbrotHalmazNagyító.java.</para>
                <para><inlinemediaobject>
                        <imageobject>
                            <imagedata fileref="kepek/encoding1-2.png"/>
                        </imageobject>
                    </inlinemediaobject></para>
                <para>Az encoding kulcsszó segítségével adjuk meg karakterkódolást amely
                    segítségével értelmezni akarjuk a kódot. Jelen helyzetben ez a karakterkészlet
                    az ISO-8859-2. Ez egy szabvány amely tartalmazza az ékezetes karaktereket és így
                    ennek segítségével már működni fog a program.</para>
                <para><inlinemediaobject>
                        <imageobject>
                            <imagedata fileref="kepek/encoding2.png"/>
                        </imageobject>
                    </inlinemediaobject></para>
            </sect1>
            <sect1>
                <title>l334d1c4</title>
                <para>Írj olyan OO Java vagy C++ osztályt, amely leet cipherként működik, azaz megvalósítja ezt a betű
                    helyettesítést: <link>https://simple.wikipedia.org/wiki/Leet</link> (Ha ez első részben nem tetted meg, akkor írasd
                    ki és magyarázd meg a használt struktúratömb memóriafoglalását!)</para>
                <para>A leet cipher alapjának írnunk kell egy "ábécét", amibol majd a cipherünk
                    válogatni tud. Ehhez használni tudjuk a fenti linket, ebben találunk pár példát
                    a 1337 "ábécére".</para>
                <programlisting>import java.util.Scanner;

public class leetCipher
{
    public static void main(String[] args)
    {
        Scanner in = new Scanner(System.in);
        String text = in.next();

        for (int i = 0; i &lt; text.length(); i++)
        {
            switch (text.charAt(i))
            {
                case 'a': System.out.print("4"); break;
                case 'b': System.out.print("8"); break;
                case 'c': System.out.print("("); break;
                case 'd': System.out.print("|}"); break;
                case 'e': System.out.print("3"); break;
                case 'f': System.out.print("|="); break;
                case 'g': System.out.print("6"); break;
                case 'h': System.out.print("|-|"); break;
                case 'i': System.out.print("1"); break;
                case 'j': System.out.print("|"); break;
                case 'k': System.out.print("|&lt;"); break;
                case 'l': System.out.print("|_"); break;
                case 'm': System.out.print("(V)"); break;
                case 'n': System.out.print("/\\/"); break;
                case 'o': System.out.print("0"); break;
                case 'p': System.out.print("|D"); break;
                case 'q': System.out.print("9"); break;
                case 'r': System.out.print("|2"); break;
                case 's': System.out.print("$"); break;
                case 't': System.out.print("7"); break;
                case 'u': System.out.print("|_|"); break;
                case 'v': System.out.print("\\/"); break;
                case 'w': System.out.print("\\/\\/"); break;
                case 'x': System.out.print(")("); break;
                case 'y': System.out.print("y"); break;
                case 'z': System.out.print("2"); break;
                default: System.out.print(text.charAt(i)); break;
            }

        }
        System.out.println();
    }
}
</programlisting>
                <para>Lefuttatva:</para>
                <para><inlinemediaobject>
                        <imageobject>
                            <imagedata fileref="kepek/Leet2.png"/>
                        </imageobject>
                    </inlinemediaobject></para>
            </sect1>
            <sect1>
                <title>Fullscreen</title>
                <para>Készítsünk egy teljes képernyős Java programot!</para>
                <para>Tipp:<link>https://www.tankonyvtar.hu/en/tartalom/tkt/javat-tanitok-javat/ch03.html#labirintus_jatek</link></para>
                <para>A feladat megoldásához saját egyszerű programkódot használtam ami abból áll,
                    hogy megjelenít a képernyőre különböző gombokat, csúszkákat. A teljes képernyős
                    mód kódját a fullscreen.java  fájlban tudjuk megnézni, a fullscreen metóduson
                    belül:<programlisting>public fullscreen() {
        setUndecorated(true);
        setAlwaysOnTop(true);
        setResizable(false);
        setVisible(true);
        Toolkit tk= Toolkit.getDefaultToolkit();
        
        int x=(int) tk.getScreenSize().getWidth();
        int y=(int) tk.getScreenSize().getHeight();
        
        setSize(x, y);
        initComponents();
    }</programlisting></para>
                <para>Íme a lefutott teljesképernyős program:</para>
                <para><inlinemediaobject>
                        <imageobject>
                            <imagedata fileref="kepek/fullscreen2.png"/>
                        </imageobject>
                    </inlinemediaobject></para>
            </sect1>
        </chapter>
        <chapter>
            <title>5. hét - „Helló, Stroustrup!”</title>
            <subtitle>5. hét Objektumorientált programozási nyelvek típusrendszere (pl.:
                Java, C#) és 6. hét Típusok tagjai: mezők, (nevesített) konstansok,
                tulajdonságok, metódusok, események, operátorok, indexelők,
                konstruktorok, destruktorok, beágyazott típusok.Összevonva.</subtitle>
            <sect1>
                <title>JDK osztályok</title>
                <para>Írjunk olyan Boost C++ programot (indulj ki például a fénykardból) amely kilistázza a JDK összes
                    osztályát (miután kicsomagoltuk az src.zip állományt, arra ráengedve)!</para>
                <para>Források:<link>https://github.com/edeszilagyi/Prog2/tree/master/5.het/JDK%20oszt%C3%A1lyok</link></para>
                <para>A JDK program elkészítéséhez mintául szolgálhat a fenykard.cpp fájl, melynek
                    függvénye a fájlok kereséséért és listázásáért felelos. A boost.cpp-vel tehát a
                    JDK-ban található src.zip-ben lévő java állományokat fogjuk kilistázni a
                    könyvtárszerkezet kicsomagolása után, majd ezek alapján kiiratjuk a JDK
                    osztályok számát. A Boost könyvtár segítségével rekurzívan megyünk végig a
                    könyvtárszerkezeten, így a java fájlokban lévő osztályok kigyűjtése felgyorsul
                    és leegyszerűsödik. Ha az src.zip tartalmát kicsomagoltuk, akkor következhet a
                    .cpp fordítása. Ezután ha argumentumként megadjuk az src mappát utána
                    futtatáskor megkapjuk a JDK osztályok számát. A kódok futatása:</para>
                <para><inlinemediaobject>
                        <imageobject>
                            <imagedata fileref="kepek/jdk1.png"/>
                        </imageobject>
                    </inlinemediaobject></para>
                <para><inlinemediaobject>
                        <imageobject>
                            <imagedata fileref="kepek/jdk2.png"/>
                        </imageobject>
                    </inlinemediaobject></para>
            </sect1>
            <sect1>
                <title>Változó argumentumszámú ctor</title>
                <para>Készítsünk olyan példát, amely egy képet tesz az alábbi projekt Perceptron osztályának bemenetére
                    és a Perceptron ne egy értéket, hanem egy ugyanakkora méretű „képet” adjon vissza. (Lásd még a 4
                    hét/Perceptron osztály feladatot is.)</para>
                <para>A megoldás forrása:<link
                        xlink:href="https://github.com/edeszilagyi/Prog2/tree/master/5.het/Változó%20argumentumszámú%20ctor"
                    /></para>
                <para>A kétdimenyiós halmaz png ábráját fogjuk eloször létrehozni a mandel.cpp file
                    segítségével. hogy látjuk, a mandel.cpp sikeres fordításához és futtatásához
                    szükségünk lesz a libpng, libpng++ könyvtárakra és a png++/png.hpp fájlra.A
                    könyvtárakat a sudo parancs segítségével tudjuk telepíteni, viszont a headerhez
                    le kell töltenünk a png++ hivatalos oldaláról a becsomagolt telepíto
                        állományokat:<link
                        xlink:href="http://download.savannah.nongnu.org/releases/pngpp/png++-0.2.9.tar.gz"
                    /><programlisting>//A terminálba leadott parancsok:
$ sudo apt-get install libpng-dev
$ sudo apt-get install libpng++-dev
$ tar -zxf png++-0.2.9.tar.gz
$ cd ./png++-0.2.9
$ make</programlisting></para>
                <para>Ezután lehet fordítani és futtatni a programot:</para>
                <para><inlinemediaobject>
                        <imageobject>
                            <imagedata fileref="kepek/valtarg1.png"/>
                        </imageobject>
                    </inlinemediaobject></para>
                <para>A perceptron az egyik legegyszerűbb előrecsatolt neurális hálózat. A main.cpp
                    segítségével fogjuk szimulálni a hiba-visszaterjesztéses módszert, mely a
                    többrétegű perceptronok egyik legfőbb tanítási módszere. Ahhoz, hogy ezt
                    fordítani és futtatni tudjuk később, szükségünk lesz az mlp.hpp fájlra, mely már
                    tartalmazza a Perceptron osztályt. Az eloző program futtatásával létrejött
                    Mandelbrot png ábrát fogjuk beimportálni. A fájloknak köszönhetően megadhatjuk a
                    neuronok darabszámát. A mandel.png alapján új képet állítunk elő. A visszakapott
                    értékeket megfeleltetjük a blue értékeknek. A 4.heti Perceptron feladatához
                    képest módosításokat kell végeznünk a header file-on is, ugyanis új képet
                    akarunk eloállítani. Az operátor már egy tömböt térít vissza, melynek
                    segítségével bele tudunk nyúlni a képbe.</para>
                <para><inlinemediaobject>
                        <imageobject>
                            <imagedata fileref="kepek/valtarg2.png"/>
                        </imageobject>
                    </inlinemediaobject></para>
            </sect1>
            <sect1>
                <title>Összefoglaló</title>
                <para>Az előző 4 feladat egyikéről írj egy 1 oldalas bemutató „”esszé szöveget!</para>
                
                    <para><emphasis role="underline">Másoló-mozgató
                            szemantika</emphasis></para><orderedlist>
                            <listitem>
                                <para><emphasis role="underline"><emphasis role="bold">Másoló
                                            szemantika</emphasis></emphasis><emphasis role="underline">:</emphasis></para>
                            </listitem>
                        </orderedlist><para> Ha van az osztályban dinamikus adattag, akkor
                            alapértelmezésben tiltjuk , míg privátban deklaráljuk a másoló
                            konstruktort és másoló értékadást.Különben alkalmazzuk a “Rule of three”
                            szabályt.</para><para>A Rule of three szabály kimondja, hogy ha
                            dinamikus tagot aggregáló osztályban kell implementálni:</para><itemizedlist>
                            <listitem>
                                <para>Destruktort,</para>
                            </listitem>
                            <listitem>
                                <para>Másoló konstruktort,</para>
                            </listitem>
                            <listitem>
                                <para>Vagy másoló értékadást</para>
                            </listitem>
                        </itemizedlist><para>Akkor nagy valószínűséggel mindhármat implementálni
                            kell.</para><para>Példa Rule of three-re:</para>
                <programlisting>Int(const Int&amp;);
Int(Int&amp;&amp;); //Rule of 5
Int&amp; operator=(const Int&amp;);
Int&amp; operator=(Int&amp;&amp;);
~Int();</programlisting>
                <para>
                    2.<emphasis role="underline"><emphasis role="bold">Mozgató szemantika:</emphasis></emphasis></para>
                <para> C++11-be bekerűlt a mozgató konstruktor, amely alkamazása drasztikusan
                       hatékonyabbá tette a kódokat. A mozgató konstruktor legfontosabb
                       tulajdonsága, hogy a használatával elkerülhető a memória újraelosztása
                       és ugyanannyi memóriát használ mint amennyit az eredeti objektum
                       használt, aminek ideiglenes funkciója van, mivel miután átadta az
                       értéket az új objektumnak törlésre kerül. Ahhoz, hogy alkalmazni tudjuk
                       a mozgató szemantikát, először meg kell oldanunk azt a problémát, hogy
                       az eredeti objektumot hibamentesen töröljük.
                </para>
                <para> Példa:</para>
                <programlisting>#include&lt;bits/stdc++.h> 
int main() 
{ 
	std :: vector &lt;int> vec1 {1, 2, 3, 4, 5}; 
	std :: vector &lt;int> vec2 {6, 6, 6, 6, 6}; 

	
	std :: cout &lt;&lt; "1.vektor elemei :"; 
	for(int i = 0; i &lt; vec1.size(); i++) 
		std :: cout &lt;&lt; " " &lt;&lt; vec1[i]; 
	std :: cout &lt;&lt; "\n"; 
	
	std :: cout &lt;&lt; "2.vektor elemei :"; 
	for(unsigned int i = 0; i &lt; vec2.size(); i++) 
		std :: cout &lt;&lt; " " &lt;&lt; vec2[i]; 
	std :: cout &lt;&lt; "\n\n"; 
	
	// elso 3 elemet az 1.vektorbol move-olja a 2.vektor 1.elemetol 
	std :: move (vec1.begin(), vec1.begin() + 3, vec2.begin()); 
	
	std :: cout &lt;&lt; "2.vektor elemei std::move utan:"; 
	for(unsigned int i = 0; i &lt; vec2.size(); i++) 
		std :: cout &lt;&lt; " " &lt;&lt; vec2[i]; 
	std :: cout &lt;&lt; "\n"; 



	return 0; 
} </programlisting>
             <para>Lefuttatva:</para>
             <para><inlinemediaobject>
                        <imageobject>
                            <imagedata fileref="kepek/asd.png"/>
                        </imageobject>
                    </inlinemediaobject></para>
             <para>
                    <table frame="all">
                        <title>Copy ctor vs Move ctor</title>
                        <tgroup cols="2">
                            <colspec colnum="1" colwidth="1*" colname="Másoló konstruktor"/>
                            <colspec colname="Mozgató konstruktor" colnum="2" colwidth="1*"/>
                            <thead>
                                <row>
                                    <entry>
                                        <para>Másoló konstruktor</para>
                                    </entry>
                                    <entry>
                                        <para>Mozgató konstruktor</para>
                                    </entry>
                                </row>
                            </thead>
                            <tbody>
                                <row>
                                    <entry>
                                        <para>Az argumentum referenciaként a bal oldali értéket
                                            kapja.</para>
                                    </entry>
                                    <entry>
                                        <para>Az argumentum referenciaként a jobb oldali értéket
                                            kapja.</para>
                                    </entry>
                                </row>
                                <row>
                                    <entry>
                                        <para>Új objektumot hoz létre a kapott objektumból az által,
                                            hogy lemásolja az összes értékét egy új memória
                                            címre.</para>
                                    </entry>
                                    <entry>
                                        <para>Új objektumot hoz létre, de ugyanannyi memóriát
                                            használ mint az átadott objektum.</para>
                                    </entry>
                                </row>
                                <row>
                                    <entry>
                                        <para>Nem hatékony, mivel sok memória elosztást használ
                                            működése során az új objektumok létrehozására.A mozgató
                                            konstruktor használata sokkal hatékonyabb.</para>
                                    </entry>
                                    <entry>
                                        <para>Memóriahasználatának nagy részét a kapott objektum
                                            teszi ki, ezért hatékonyabb, mint a másoló
                                            konstruktor.</para>
                                    </entry>
                                </row>
                                <row>
                                    <entry>
                                        <para>Nem változtat semmit a kapott objektumon, ezért a
                                            kapott objektum használható másoló operátor után
                                            is.</para>
                                    </entry>
                                    <entry>
                                        <para>Mivel a mozgató konstruktor a kapott objektum memória
                                            blokkjait használja, ezért a kapott objektum nem
                                            használható mozgató operátor után.</para>
                                    </entry>
                                </row>
                            </tbody>
                        </tgroup>
                    </table>
                </para>
               
            </sect1>
        </chapter>
        <chapter>
            <title>6. hét - „Helló, Gödel!”</title>
            <subtitle>7. hét Interfészek. Kollekciók. és 8. hét Funkcionális nyelvi
                elemek. Lambda kifejezések.Összevonva.</subtitle>
            <sect1>
                <title>STL map érték szerinti rendezése</title>
                <para>Például:<link>https://github.com/nbatfai/future/blob/master/cs/F9F2/fenykard.cpp#L180</link></para>
                <para>Források:<link>https://github.com/edeszilagyi/Prog2/tree/master/6.het/stl%20map</link></para>
                <para>Ebben a példában megismerjük a C++ STL map adatszerkezetét. Ez az
                    adatszerkezet úgynevezett párok tárolására képes, általában a párok első elemét
                    hívjuk kulcsnak, a másodikat pedig értéknek. Új értékeket az  insert() metódus
                    meghívásával lehet hozzáadni, mely paramétereként elfogad egy std::pair típusú
                    objektumot. A mapoknak két tagjuk van (most string és int), ezeket rendeljük
                    hozzá egy pair vektorhoz, és ezt követően rendezünk. Érték szerint csökkenő
                    sorrendben történik a rendezés (p1.second és p2.second használatával). Lambda
                    kifejezés segítségével rendezünk: a nagyobb elemek lesznek elől, ugyanis ha az
                    első pair érték nagyobb, akkor igazzal tér vissza a függvény.
                    <programlisting>std::vector&lt;std::pair&lt;std::string, int>> sort_map ( std::map &lt;std::string, int> &amp;rank )
{
        std::vector&lt;std::pair&lt;std::string, int>> ordered;

        for ( auto &amp; i : rank ) {
                if ( i.second ) {
                        std::pair&lt;std::string, int> p {i.first, i.second};
                        ordered.push_back ( p );
                }
        }

        std::sort (
                std::begin ( ordered ), std::end ( ordered ),
        [ = ] ( auto &amp;&amp; p1, auto &amp;&amp; p2 ) {
                return p1.second > p2.second;
        }
        );

        return ordered;
}</programlisting></para>
            </sect1>
            <sect1>
                <title>Alternatív Tabella rendezése</title>
                <para>Mutassuk be a
                        <link>https://progpater.blog.hu/2011/03/11/alternativ_tabella</link> a
                    programban a java.lang Interface Comparable&lt;T> szerepét!</para>
                <para>Források:<link>https://github.com/edeszilagyi/Prog2/tree/master/6.het/alternativ%20tabella</link></para>
                <para>Az alternatív tabella a Google algoritmusán, a PageRank-en alapszik. A
                    PageRank ötlete, hogy azok a weblapok jobb minőségűek, amelyekre jobb minőségű
                    lapok mutatnak. Jelen esetben az foglal előkelőbb  helyet a labdarúgó
                    bajnokságon, aki előkelőbb helyen lévő csapatoktól szerez pontot.  A táblázatban
                    lévő eredményeket a kereszt és kereszt1 nevű kétdimenziós tömbökbe dobjuk bele a
                    Wiki2Matrix osztály-ban. Azért kell mégegy kereszt1nevű táblázat mert a magyar
                    bajnokságban mindenki 3 alkalommal játszik mindenkivel. Vegyük például a
                    2018-19-es magyar labdarúgó bajnokság első osztályának eredményeit. Az üres
                    legyen 0, a győzelem 1, a döntetlen 2, a vereség pedig 3. A példa alapján a
                    mátrixokba tehát a következő értékek
                    kerülnek:<programlisting>int[][] kereszt = {
      {0, 1, 1, 3, 1, 1, 2, 1, 1, 1, 2, 3},
      {1, 0, 1, 1, 2, 1, 2, 2, 1, 1, 2, 3},
      {1, 1, 0, 3, 1, 2, 2, 1, 2, 2, 3, 3},
      {1, 2, 1, 0, 1, 1, 1, 1, 2, 1, 1, 2},
      {3, 3, 2, 1, 0, 3, 3, 3, 3, 1, 2, 3},
      {3, 1, 2, 3, 1, 0, 3, 1, 2, 1, 3, 2},
      {3, 2, 1, 3, 1, 2, 0, 3, 1, 1, 2, 1},
      {2, 3, 1, 3, 1, 3, 2, 0, 3, 1, 1, 3},
      {2, 1, 3, 3, 2, 1, 1, 1, 0, 1, 2, 3},
      {1, 3, 1, 1, 1, 2, 1, 3, 2, 0, 3, 1},
      {2, 1, 1, 2, 1, 1, 2, 3, 2, 1, 0, 1},
      {1, 2, 3, 1, 1, 1, 1, 3, 2, 3, 1, 0}
    };
    int[][] kereszt2 = {
      {0, 2, 3, 1, 3, 0, 0, 0, 1, 0, 0, 3},
      {0, 0, 1, 0, 1, 3, 1, 1, 1, 0, 0, 0},
      {0, 0, 0, 0, 3, 0, 0, 0, 1, 1, 1, 1},
      {0, 1, 1, 0, 1, 0, 0, 0, 1, 0, 1, 1},
      {0, 0, 0, 0, 0, 0, 0, 1, 2, 1, 1, 2},
      {2, 0, 2, 3, 3, 0, 1, 0, 0, 0, 0, 0},
      {1, 0, 1, 3, 1, 0, 0, 0, 1, 0, 0, 0},
      {3, 0, 1, 3, 0, 3, 3, 0, 0, 0, 0, 0},
      {0, 0, 0, 0, 0, 1, 0, 1, 0, 2, 3, 2},
      {2, 1, 0, 2, 0, 3, 1, 1, 0, 0, 0, 0},
      {2, 2, 0, 0, 0, 1, 1, 2, 0, 3, 0, 0},
      {0, 1, 0, 0, 0, 1, 1, 1, 0, 2, 1, 0}
    };</programlisting></para>
                <para>A fordítás és futtatás után kapott új értékeket az AlternatívTabella osztályba
                    kell belehelyezni, a double[][] Lnk = {} rész kapcsos zárójelei közé. Az
                    csapatNevE tömbbe kerülnek a csapatok nevei a táblázatban való megjelenésük
                    alapján. Az ep tömbbe az eredeti tabella pontjait írjuk be. Készítünk egy
                    csapatNevL tömböt is, melybe a Wiki2Matrix kereszt nevű mátrixa alapján
                    létrejött sorrend szerint kerülnek be a csapatok.</para>
                <para>Az alternatív tabella értékeinek összehasonlításához, rendezéséhez igénybe
                    vesszük a java.lang package Comparable interfészét. Az interface lehetové teszi,
                    hogy képések legyünk alkalmazni a listákra és tömbökre definiált függvényeket. A
                    compareTo metódus a paraméterként megadott objektumot hasonlítja össze az
                    aktuális objektummal. Háromféle értéket adhat vissza: pozitív, negatív számot
                    vagy
                    nullát.<programlisting>class Csapat implements Comparable&lt;Csapat> {

  protected String nev;
  protected double ertek;

  public Csapat(String nev, double ertek) {
    this.nev = nev;
    this.ertek = ertek;
  }

  public int compareTo(Csapat csapat) {
    if (this.ertek &lt; csapat.ertek) {
      return -1;
    } else if (this.ertek > csapat.ertek) {
      return 1;
    } else {
      return 0;
    }
  }
}</programlisting></para>
                <para><inlinemediaobject>
                        <imageobject>
                            <imagedata fileref="kepek/alternativtabella.png"/>
                        </imageobject>
                    </inlinemediaobject></para>
                
            </sect1>
            <sect1>
                <title>Prolog családfa</title>
                <para>Ágyazd be a Prolog családfa programot C++ vagy Java programba! Lásd
                    para_prog_guide.pdf!</para>
                <para>Források:<link>https://github.com/edeszilagyi/Prog2/tree/master/6.het/Prolog</link></para>
                <para>A Prolog egy olyan programozási nyelv, melynek segítségével matematikai
                    logikai formulákat tudunk vizsgálni. A matematikai logikáról ez a feladat nem
                    fog részletesebb tájékoztatást nyújtani, a fentebb lévő pdf-ben találhattok
                    példákat a mélyebb megértéshez. Annyit fontos megemlíteni, hogy a program az
                    elsorendű logikán alapszik. Tehát itt az atomi formulák mellett megjelennek a
                    függvényszimbólumok és a kvantorok, mint a logikai formulák építoelemei. </para>
                <para>A programunk Java programban íródott, mely az SWI-Prolog könyvtárat használja.
                    Alapvetoen a program úgy működik, hogy a elsőnek betöltjük a Prolog fájlt, majd
                    arról készítünk lekérdezéseket.  A family.pl fájl tartalmazza a pdf-ben megadott
                    Prolog programot:</para>
                <para>
                    <programlisting>férfi(nándi).
férfi(matyi).
férfi(norbi).
férfi(dodi).
férfi(joska).
nő(gréta).
nő(erika).
nő(kitti).
nő(marica).
gyereke(nándi, norbi).
gyereke(matyi, norbi).
gyereke(gréta, norbi).
gyereke(nándi, erika).
gyereke(matyi, erika).
gyereke(gréta, erika).
gyereke(norbi, dodi).
gyereke(norbi, kitti).
gyereke(erika, joska).
gyereke(erika, marica).
apa(X) :- férfi(X), gyereke(_Y, X).
apja(X, Y) :- férfi(X), gyereke(Y, X).
anya(X) :- nő(X), gyereke(_Y, X).
anyja(X, Y) :- nő(X), gyereke(Y, X).
nagyapa(X) :- apja(X, Y), (apja(Y, _U); anyja(Y, _Z)).
nagyapja(X, Z) :- apja(X, Y), (apja(Y, Z); anyja(Y, Z)).</programlisting>
                </para>
                <para>Ezt a programunkba a követkeő módon fogjuk
                    beolvasni:<programlisting>String s = "consult('family.pl')";
        Query q = new Query(s); 
        System.out.println(q.hasSolution());</programlisting></para>
                <para>Itt jól látható, hogy hogyan fog működni maga az alkalmazás. Elsőnek megadunk
                    egy stringet, mely kiértékelni kívánt formulát tartalmazza. Majd létrehozunk egy
                    Query osztályú objektumot hozunk létre. Ez az osztály teszi lehetové, hogy
                    kiértékeljük a formula igazságértékét, vagy az egyes változók lehetséges
                    értékeit. Ha csak az igazságértékre vagyunk kíváncsiak, akkor a hasSolution()
                    függvényt kell használni. Ha itt hamis eredményt ad, akkor a fájlt nem
                    találja.<programlisting>String t2 = "apa(gréta)";
        System.out.println(t2 + " is " + (Query.hasSolution(t2) ? "provable" : "not provable"));</programlisting></para>
                <para>Az első példa tehát azt mutatja be, hogy hogyan lehet megtudni a formula
                    igazságértékét. Jelen esetben azt vizsgáljuk, hogy Gréta apának tekinthető-e.
                    Nyilván nem, vagyis a terminálban a "not provable" kifejezés ˝ jelenik
                    meg.<programlisting> String t3 = "nagyapja(X, matyi)";
        System.out.println("each solution of " + t3);
        Query q3 = new Query(t3);
        while (q3.hasMoreSolutions()) {
            Map&lt;String, Term> s3 = q3.nextSolution();
            System.out.println("X = " + s3.get("X"));
        }  </programlisting></para>
                <para>A változók értékének lehetséges értékeit kétféleképpen lehet felsorolni. A
                    fenti példában azokat az Xeket keressük, akik Matyi nagyapjai lehetnek. Ezt úgy
                    tudjuk megfogalmazni matematikai logikával, hogy azokat az X-eket keressük, akik
                    Matyi apjának vagy anyjának az apja. Tehát végig iterálunk a lehetséges
                    X-eken.</para>
                
            </sect1>
        </chapter>
        <chapter>
            <title>7. hét - „Helló, !”</title>
            <subtitle>9. hét Adatfolyamok kezelése, streamek és 11. hét I/O,
                állománykezelés. Szerializáció.</subtitle>
            <sect1>
                <title>FUTURE tevékenység editor</title>
                <para>Javítsunk valamit a ActivityEditor.java JavaFX programon!</para>
                <para><link>https://github.com/nbatfai/future/tree/master/cs/F6</link></para>
                <para>Itt láthatjuk működésben az alapot: <link>https://www.twitch.tv/videos/222879467</link></para>
                <para>A future projekt eredeti célja egy város alternatív jövoinek legenerálása, a
                    legenerált jövők elemzése volt. A future6-hoz készült egy tulajdonság editor,
                    melyben a hallgatók az adott nap tevékenységeit tudták feljegyezni.</para>
                <para>A javításom a programon a lett hogy a főbb címkék alapból ki vannak nyitva,
                    így megkönnyítik a felhasználó dolgát a program használata közben, mivel így
                    egből észreveszi azt a dolgot amit keres. </para>
                <para>A program működés közben:</para>
                <para><inlinemediaobject>
                        <imageobject>
                            <imagedata fileref="kepek/future.png"/>
                        </imageobject>
                    </inlinemediaobject></para>
            </sect1>
            <sect1>
                <title>OOCWC Boost ASIO hálózatkezelése</title>
                <para>Mutassunk rá a scanf szerepére és használatára! <link>https://github.com/nbatfai/robocaremulator/blob/master/justine/rcemu/src/carlexer.ll</link></para>
                <para>Scanf beépített függvény segítségével adatokat olvashatunk be, amelyet
                            típus szerint eltérő módon kell megadni.</para>
                <para>A scanf függvény argumentumában % jel után adjuk meg a beolvasott adat
                            tipusának megfelelő jelölést, amely nagyon sok féle lehet, de a
                            legfontosabbak és a leggyakrabban használtak a következők:</para>
                <para>1) %d: adatot decimális számmá alakít</para>
                <para>2) %x: adatot hexadecimális számmá alakít</para>
                <para>3) %f: adatot lebegőpontos számmá alakít</para>
                <para>4) %s: adatot stringgé alakít</para>
                <para>A carlexer.II programban a scanf-nek az a szerepe, hogy különböző
                            adatokat olvas be, amelyek segítségével megadhatóak az autók
                            kezdőpozíciói, lehetséges útvonalai illetve az autó poziciója,
                            elhelyezkedese a program teljes működésesorán.</para>
                
            </sect1>
            <sect1><title>BrainB</title><para>Mutassuk be a Qt slot-signal mechanizmust ebben a
                    projektben:
                        <link>https://github.com/nbatfai/esporttalent-search</link></para>
                <para><emphasis
                        role="underline">Signal-slot mechanizmus</emphasis>:</para>
                <para>A signalok es slotok biztositják az objektumok közötti
                    kommunikációt.</para>
                <para> A signals and slots mechanizmus teszi egyedivé a
                    Qt-t mivel ez teljes egészében Qt-specifikus,és ez a mechanizmus különbözteti
                    meg más toolkitektől a Qt-t.</para>
                <para> Míg más toolkitek a callback
                    függvénypointer segítségével értesítenek egy esemény bekövetkeztéről, addig a
                    Qt-ben lehetőségünk van egy alternatív mechanizmust alkalmazni, ami a
                    Slot-signal mechanizmus.</para>
                <para>Signal</para>
                <para> A Qt-ban az objektumok
                    képesek magukból signalokat kiadni, sugarozni(emit), ami akkor történik, ha az
                    objektummal történt valami fontos, például megváltozott az állapota, a BrainB
                    esetében ez akkor történik meg amikor rákattintunk a négyzetbeli pontra.
                    </para>
                <para> Csak az az osztály és az osztály alosztályai képesek signalt
                    sugározni, amelyikben definiálva van a signal. Amikor sugároz a signal, akkor a
                    slot egyből elvégződik, mint egy függvényhivás.</para>
                <para> A signalok
                    automatikusan generálodnak a moc által, ezért ezeket nem kell a .cpp fileban
                    implementálni, és nincs return értékuk.</para>
                <para>Slot</para>
                <para> A Qt-ban
                    az objektumoknak lehetnek slotjaik is, amelyek olyan speciális
                    tagfüggvények,melyek képesek érzékelni azt, ha egy másik objektumnak
                    megváltozott az állapota.</para>
                <para>Ha több slot van egy signálhoz
                    kapcsolódva, akkor a slotok egymás utan kerülnek elvágzásre.A slotok egyszerű
                    c++ függvények, azzal a különbséggel, hogy ezekhez hozzá lehet kapcsolni
                    signalokat. A slot argumentumoknak nem lehet alapértelmezett értékük, mindig
                    saját egyedi értékeket adjunk nekik.</para>
                <para>3 féle slot
                    letezik:</para>
                <para>1.Public slot: olyan slotokat tartalmaz, amelyekhez bárki
                    kapcsolhat signalt, ez nagyon hasznos mert az olyan objektumok között is
                    megoszthatunk információkat, amelyek egyébkent nem tudnak egymásrol semmit, de
                    össszekapcsoljuk a signaljaikat és slotjaikat.</para>
                <para>2.Protected slot:
                    olyan slotokat tartalmaz, amelyekhez ez az osztaly illetve alosztályai
                    kapcsolhatnak signalokat. Ez olyan slotoknak lehet hasznos, amelyeket ebben az
                    osztályban impelementáljuk.</para>
                <para>3.Private slot: csak ez az osztály
                    kapcsolhat hozzá signalt, ez olyan szorosan kapcsolt osztályok eséten hasznos,
                    amelyekhez még az alosztályai sem kapcsolódhatnak.</para>
                <para>Definiálhatjuk a
                    slotokat virtualként is.</para>
                <para> Amikor a signal-t a slot-hoz kötjük,
                    tulajdonképp elmondjuk a slot-nak, hogy melyik objektum
                    állapotváltozására kell figyelnie. Figyeljünk fel arra a tényre, hogy a
                    megfigyelt</para>
                <para>objektumnak fogalma sincs róla, hogy valaki figyel-e rá.
                    A kapcsolatért, azért,</para>
                <para>hogy történjen valami, lényegében a slot
                    objektuma felel.</para>
                <para> A signal-slot kapcsolatok miatt a számított adatok
                    értéke bármely „számszerű” adat megváltozásakor újraszámolódik.</para>
                <para>És a programról kép működése közben:</para>
                <para><inlinemediaobject>
                        <imageobject>
                            <imagedata fileref="kepek/BrainB.png"/>
                        </imageobject>
                    </inlinemediaobject></para>
                </sect1>
        </chapter>
        <chapter>
            <title>8. hét - „Helló, Lauda!”</title>
            <subtitle>10. hét Kivételkezelés. és 12. hét Reflexió. A fordítást és a
                kódgenerálást támogató nyelvi elemek (annotációk, attribútumok). Összevonva.</subtitle>
            <sect1>
                <title>Port scan</title>
                <para>Mutassunk rá ebben a port szkennelő forrásban a kivételkezelés szerepére!</para>
                <para><link>https://www.tankonyvtar.hu/hu/tartalom/tkt/javat-tanitok-javat/ch01.html#id527287</link></para>
                <para>A KapuSzkenner.java segítségével megnézhetjük, hogy gépünk éppen milyen portokat figyel. A kivételkezelés try blokkjában az argumentumként megkapott gép 1024 alatti portjain
                    próbálunk meg TCP kapcsolatot létesíteni. Ha az adott gépen egy szerverfolyamat figyeli az adott portot,
                    akkor ezt ki is iratjuk.</para>
                <programlisting>public class KapuSzkenner {
    public static void main(String[] args) {
        for (int i = 0; i &lt; 1024; ++i)
            try {
                java.net.Socket socket = new java.net.Socket(args[0], i);
                System.out.println(i + " figyeli");
                socket.close();</programlisting>
                <para>Portszkennelést páldul akkor használunk, mikor szeretnénk meggyőződni arról, hogy egy általunk üzemeltetett 
                    szerver nem fed fel túl sokat (tehát nem rendelkezik feleslegesen nyitva levo portokkal).</para>
                <para>Ezen program működési elve, hogy 0-tól 1024-ig végigmegy az összes porton, és megpróbál egy socketet
                    nyitni a java.net.Socket osztály segítségével. Amennyiben elolvassuk az ehhez az osztályhoz tartozó dokumentációt, azt láthatjuk, 
                    hogy amennyiben nem tudunk csatlakozni, úgy SecurityException hibát fog dobni a meghívás.</para>
                <para>Ennek köszönhetően egyszerűen, amennyiben nem tudunk socketet nyitni az adott porton, tudjuk, hogy nem elérhető.</para>
                <para><inlinemediaobject>
                        <imageobject>
                            <imagedata fileref="kepek/port1.png"/>
                        </imageobject>
                    </inlinemediaobject></para>
                <para><inlinemediaobject>
                        <imageobject>
                            <imagedata fileref="kepek/port2.png"/>
                        </imageobject>
                    </inlinemediaobject></para>
            </sect1>
            <sect1>
                <title>AOP</title>
                <para>Szőj bele egy átszövő vonatkozást az első védési programod Java átiratába! (Sztenderd védési
                    feladat volt korábban.)</para>
                <para>Néhány alap fogalom A csatlakozási pontvagy joint pont egy olyan pont a programban amikor valami történik. 
                    Ilyen például amikor egy metódus meghívódik vagy egy kivételt throwolunk,inicializálunk egy objektumot stb. 
                    A pointcutnak van egy jobb és bal oldala kettospont választja el a kettőt.Bal oldalon a pointcut neve és paraméterei állnak. 
                    A paraméterekben az elérhető adatokhoz férhetünk hozzá ha lefut a metódus. A jobboldalt maga a pointcut szerepel.
                    Ez általában a call vagy az execution. Ebben írjuk meg, hogy mire utal a pointcut a valódi osztályunkban.
                    Advice-ok lényegében a before, after és around. Tehát, hogy a metódus hívása elott,után vagy közben ˝
                    esetleg helyett fusson le. A within paranccsal mondhatjuk meg,hogy melyik osztályból akarjuk használni.
                    A target az a java objektum ami a metódust hívja.Argumentumok azok az értékek amiket a metódusban
                    hívunk.</para>
                <programlisting>private long egyes = 0;
private long nullas = 0;
pointcut pushback() : execution(public void push_back(char));
before(char ch): pushback() &amp;&amp; args(ch){
if(ch == ’1’){
egyes++;
} else {
nullas++;
}
}
pointcut main() : execution(public static void main(String[]));
after() : main(){
System.out.println("Egyesek száma: " + egyes);
System.out.println("Nullások száma: " + nullas);
}</programlisting>
                <para>Vegyük elsonek példának az egyesek és nullások megszámlálását. Ugyebár deklarálunk és inicializálunk 2
                    változót amibe majd tároljuk a megszámolt értékeket. Aztán jön a pointcutunk aminek a neve pushback lesz.
                    A jobb oldala maga a point cut. Tehát oda tesszük a pointcutot ahol lefut a fo program push_back(char)
                    függvénye. Aztán mielott ez lefut az argumentum karakterjét átadjuk és megnézzük egyes-e vagy nulla.
                    Majd létrehozunk egy új pointcutot a mainre. És megmondjuk, hogy miután lefut a main írjuk ki a megszámol egyesek és nullások számát.
                    Most nézzük meg a kiir függvényre való pointcut-unkat:</para>
                <programlisting>public pointcut meghiv(LZWBinFa.Csomopont n, PrintWriter os)
: call(void LZWBinFa.kiir(LZWBinFa.Csomopont, PrintWriter)) &amp;&amp; args(n,os);
after(LZWBinFa.Csomopont n, PrintWriter os) : meghiv(n, os)
{
    try{
    os=new PrintWriter("preorder.txt");
    preOrder(n,os);
    os.flush();
    }
    catch (FileNotFoundException e) {
        e.printStackTrace();
    }
    depth = 0;
    try{
    os=new PrintWriter("postorder.txt");
    postOrder(n,os);
    os.flush();
    }
    catch (FileNotFoundException e) {
    e.printStackTrace();
    }
}
public void preOrder(LZWBinFa.Csomopont n, PrintWriter p)
{
    if (n != null)
    {
        ++depth;
        for (int i = 0; i &lt; depth; ++i)
        p.print("---");
        p.print(n.getBetu () + "(" + depth + ")\n");
        preOrder (n.getBalNulla (), p);
        preOrder (n.getJobbEgy (), p);
        --depth;
    }
}
public void postOrder(LZWBinFa.Csomopont n, PrintWriter p)
{
    if (n != null)
    {
        ++depth;
        postOrder (n.getBalNulla (), p);
        postOrder (n.getJobbEgy (), p);
        for (int i = 0; i &lt; depth; ++i)
        p.print("---");
        p.print(n.getBetu () + "(" + depth + ")\n");
        --depth;
}
}</programlisting>
                <para>Na itt a pointcutunkat a kiir függvény hívására tesszük.Argumentumként
                    átvesszük a printwriter és a csomópont n-t. Aztán a már megszokott pre és post
                    order bejárásunkat láthatjuk függvényként ez bevprogról már ismeros volt.
                    Ugyebár alapból inorder-ben iratjuk ki. Aztán megmondjuk, hogy minden egyes kiir
                    hívás után hajtódjon végre a másik két kiir függvény is. Fontos a try-catch
                    szerkezet máskülönben errort kapunk, hogy nincs ami elkapja az exceptiont.
                    Emellett nagyon fontos szerepet játszik még az, hogy 2 FileWriter os-t hozok
                    létre. És mind a 2-t flush-ölöm.Ugyebár a flush a bufferben lévo stringet
                    azonnal kiírja.</para>
            </sect1>
            <sect1>
                <title>Android Játék</title>
                <para>Írjunk egy egyszerű Androidos „játékot”! Építkezzünk például a 2. hét „Helló, Android!” feladatára!</para>
                <para>Egy működo androidos játékot kellett írni, amit én ezt a alábbi youtube
                    tutorial alapján valósítottam meg:<link>https://www.youtube.com/watch?v=apDL78MFR3o</link>
                    A játék egy tictactoe játék, ami a játék szabályai alapján működik, számolja a
                    játékosok pontjait, valamint egy reset funkció is bele van építve, ami az eddig
                    összegyűjtött pontokat nullázza.</para>
            </sect1>
        </chapter>
        <chapter>
            <title>9. hét - „Helló, Calvin!”</title>
            <subtitle>13. hét Multiparadigmás nyelvek és 14. hét Programozás
                multiparadigmás nyelveken. Összevonva.</subtitle>
            <sect1>
                <title>MNIST</title>
                <para>Az alap feladat megoldása, +saját kézzel rajzolt képet is ismerjen fel,</para>
                <para><link>https://progpater.blog.hu/2016/11/13/hello_samu_a_tensorflow</link>-bol Háttérként ezt vetítsük le:</para>
                <para><link>https://prezi.com/0u8ncvvoabcr/no-programming-programming/</link></para>
                <para/>
            </sect1>
            <sect1>
                <title>Android telefonra a TF objektum detektálója</title>
                <para>Telepítsük fel, próbáljuk ki!</para>
                <para/>
            </sect1>
        </chapter>
    </part>
</book>
