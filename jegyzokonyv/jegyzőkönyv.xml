<?xml version="1.0" encoding="UTF-8"?>
<?xml-model href="http://docbook.org/xml/5.1/rng/docbook.rng" schematypens="http://relaxng.org/ns/structure/1.0"?>
<?xml-model href="http://docbook.org/xml/5.1/rng/docbook.rng" type="application/xml" schematypens="http://purl.oclc.org/dsdl/schematron"?>
<book xmlns="http://docbook.org/ns/docbook"
    xmlns:xlink="http://www.w3.org/1999/xlink" version="5.1">
    <info>
        <title>Jegyzökönyv</title>
        <author>
            <personname>Szilágyi-Czumbil Ede Balázs</personname>
        </author>
    </info>
    <part>
        <title/>
        <chapter>
            <title>Infók</title>
            <para>Neptun kód: CMY9W3</para>
            <para>
                Git repó:<link>https://github.com/edeszilagyi/Prog2</link>
            </para>
            <para>e-mail: <email>ede.szilagyi@yahoo.com</email></para>
        </chapter>
        <chapter>
            <title>0. hét - „Helló, Berners-Lee!</title>
            <sect1>
                <title>Java, C++ összehasonlítás</title>
                <para>Könyvek:C++: Benedek Zoltán, Levendovszky Tihamér Szoftverfejlesztés C++
                    nyelven Java: Nyékyné Dr. Gaizler Judit et al. Java 2 útikalauz programozóknak
                    5.0 I-II</para>
                <para>A Java nyelv teljesen objektum orientált nyelv. Ezzel szemben a C++ lehetőséget ad a generikus programozásra is. 
                    A két programnyelv változó kezelése eltérő. Java esetén minden objektum referencia. Ez azt
                    jelenti, hogy az értéküket közvetlen a referencián keresztül érjük el. Mindkét nyelv támogatja a publikus, privát és statikus objektum kezelést.
                    Fordító szempontjából amíg a C++ kódot elég natívan fordítani, addig a Java-hoz szükség van egy virtuális
                    fordítóra, ami futtatja a kódot. Emiatt nagyobb az eroforrás igénye is.Java-ban nem nagyon kell foglalkozni a memória szeméttel, mivel van automatikus garbage collector, ami
                    üríti azt, míg C++-nál fel kell szabadítani a memóriát
                </para>
            </sect1>
            <sect1>
                <title>Python</title>
                <para>Könyv: Forstner Bertalan, Ekler Péter, Kelényi Imre: Bevezetés a mobilprogramozásba.
                    Gyors prototípus-fejlesztés Python és Java nyelven</para>
                <para>  A Python tulajdonképpen egy szkriptnyelv, de nagyon sok csomagot is és beépített
                    eljárást is tartalmaz, ezért komolyabb alkalmazások megírására és komolyabb problémák
                    megoldására is használható.Más modulokkal is együtt tud működni egy Python komponens. A
                    Python egy nagyon magas szintű programozási nyelv.  Pyton esetén nincs szükség
                    fordítás-ra. A Python interpreter elérhető számos platformon. A Pythont könyű hasznáni,
                    megbízható és jelentős támogatást biztosít hibák javítására. A Pythonban minden adat
                    objektumként szerepel. A rajtuk végzendő műveleteket az objektum típusa határozza meg,
                    amit a rendszer futási idoben határoz meg, így nekünk nem kell megadni. A következő
                    típusok lehetnek: szám, string, tuple, list, dictionary. A számok lehetnek egészek,
                    decimálisak, oktálisak vagy akár hexadecimálisak is. Szöveg típus esetén a szöveget két
                    aposztróf közé írva kell megadni.</para>
            </sect1>
        </chapter>
        <chapter>
            <title>1. hét - „Helló, Arroway!”</title>
            <sect1>
                <title>OO szemlélet</title>
                <para>A módosított polártranszformációs normális generátor beprogramozása Java nyelven. Mutassunk rá, hogy
                    a mi természetes saját megoldásunk (az algoritmus egyszerre két normálist állít elo, kell egy példánytag, ˝
                    amely a nem visszaadottat tárolja és egy logikai tag, hogy van-e tárolt vagy futtatni kell az algot.) és az
                    OpenJDK, Oracle JDK-ban a Sun által adott OO szervezés ua.!
                    Segédlink: <link>https://arato.inf.unideb.hu/batfai.norbert/UDPROG/deprecated/Prog1_5.pdf</link> (16-22 fólia)</para>
                
                <para>A kód:</para>
                <programlisting>public class PolarGenerator {

	boolean nincsTarolt = true;
	double tarolt;
	
	public PolarGenerator() {
		nincsTarolt = true;
	}
	
	public double kovetkezo() {
		if(nincsTarolt) {
			double u1, u2, v1, v2, w;
			do {
				u1 = Math.random();
				u2 = Math.random();
				
				v1 = 2 * u1 - 1;
				v2 = 2 * u2 - 1;
				
				w = v1 * v1 + v2 * v2;
			} while(w > 1);
			double r = Math.sqrt(-2 * Math.log(w) / w);
			
			tarolt = r * v2;
			
			nincsTarolt = !nincsTarolt;
			return r * v1;
		} else {
			nincsTarolt = !nincsTarolt;
			return tarolt;
		}
	}
	
	public static void main(String[] args) {
		PolarGenerator pg = new PolarGenerator();
		
		for(int i = 0; i &lt; 10; i++) {
			System.out.println(pg.kovetkezo());
		}
	}
}
</programlisting>
                <para>A program kezdésként két változót állít elő. Magát a tárolt számot(double) és
                    egy boolean típusu változót ami tárolja hogy van-e változó.Ezután ellenőrzi hogy
                    van e tárolt változó,ha van akkor generál 2 random számot amivel elvégzi az
                    adott műveletet. Ezt addig folytatja amíg a kapott eredmény kisebb lesz 1nél .
                    Ha a nincs tárolt változó false akkor visszaadja a tárolt változóban lévő
                    értéket. </para>
                <para>Miután futtatuk:</para>
                <para><inlinemediaobject>
                    <imageobject>
                        <imagedata fileref="kepek/oomegold.jpg"/>
                    </imageobject>
                </inlinemediaobject></para>
            </sect1>
            <sect1>
                <title>„Gagyi”:</title>
                <para>Az ismert formális2 „while (x &lt;= t &amp;&amp; x >= t &amp;&amp; t != x);”
                    tesztkérdéstípusra adj a szokásosnál (miszerint x, t az egyik esetben az
                    objektum által hordozott érték, a másikban meg az objektum referenciája)
                    „mélyebb” választ, írj Java példaprogramot mely egyszer végtelen ciklus, más x,
                    t értékekkel meg nem! A példát építsd a JDK Integer.java forrására3 , hogy a
                    128-nál inkluzív objektum példányokat poolozza! </para>
                <para>A JDK forrásán belül, a java/lang/Integer.java forrásban látszik hogy az
                    Integer class-nak van egy alapértelmezett cache-je amiben vannak előre
                    elkészített integer osztálybeli objektumok itt el vannak tárolva a -128tól 127ig
                    terjedő számok hogy segítse a programok gyorsabb működését és jobb
                    memóriahasználatát.<programlisting>public static Integer valueOf(int i) {
if (i >= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high)
return IntegerCache.cache[i + (-IntegerCache.low)];
return new Integer(i);
}</programlisting></para>
                <para>E miatt ha a programunkban a [-128,127] intervallumon kívüli értéket adunk meg
                    akkor az egyenlőség hamis lesz mivel két új obiektum fog létrejönni és emiatt
                    végtelen ciklust kapunk.</para>
                <para>Ha viszont az értékek az intervallumon belül van akkor igaz lesaz
                    egyenlőség.</para>
                <para>a program ami végtelen ciklust ad:</para>
                <programlisting>public class Gagyi {

	public static void main(String[] args) {
		
		
		Integer i = 130;
		Integer j = 130;
		
		System.out.println("i = " + i + " j = " + j);

		while(i &lt;= j &amp;&amp; i >= j &amp;&amp; i != j) {
			
		}	
		
	}
}
</programlisting>
                <para>lefuttatva:</para>
                <para><inlinemediaobject>
                    <imageobject>
                        <imagedata fileref="kepek/gagyimegold1.png"/>
                    </imageobject>
                </inlinemediaobject></para>
                <para>a program ami nem végtelen ciklust ad:</para>
                <programlisting>public class Gagyi {

	public static void main(String[] args) {
		
		Integer i = 10;
		Integer j = 10;
		
		System.out.println("i = " + i + " j = " + j);

		while(i &lt;= j &amp;&amp; i >= j &amp;&amp; i != j) {
			
		}	
		
	}
}
</programlisting>
                <para>lefuttatva:</para>
                <para><inlinemediaobject>
                    <imageobject>
                        <imagedata fileref="kepek/gagyimegold2.png"/>
                    </imageobject>
                </inlinemediaobject></para>
                
            </sect1>
            <sect1>
                <title>Yoda</title>
                <para>Írjunk olyan Java programot, ami java.lang.NullPointerEx-el leáll, ha nem követjük a Yoda
                    conditions-t! <link>https://en.wikipedia.org/wiki/Yoda_conditions</link>
                </para>
                <para>A kód:</para>
                <programlisting>public class Yoda {

	public static void main(String[] args) {
		
		final String str = null;
		
		try {
			if(str.equals("...")) {
				//Do something
			}
			System.out.println("1. Success");

		} catch(Exception e) {
			System.err.println(e.getMessage());
		}

		try {
			if("...".equals(str)) {
				//Do something
			}
			System.out.println("2. Success");

		} catch(Exception e) {
			System.err.println(e.getMessage());
		}
	}
}
</programlisting>
                <para>A Yoda condition olyan programozási stílus ahol a kifejezések fordított
                    sorrendben vannak a tipikus,megszokott sorrendhez képest.</para>
                <para>Az előző programrészlet pont ezt próbálja szemléltetni. amikor elősször
                    próbáljuk ellenőrizni az egyenlőséget NullPointerEx-el leáll mivel megsértettük
                    a Yoda condtition-t (null),de mikor megcseréltük a sorrendet már sikerrel
                    jártunk (Success)</para>
                <para>Lefuttatva:</para>
                <para><inlinemediaobject>
                    <imageobject>
                        <imagedata fileref="kepek/yodamegold.jpg"/>
                    </imageobject>
                </inlinemediaobject></para>
            </sect1>
        </chapter>
        <chapter>
            <title>2. hét - „Helló, Liskov!”</title>
            <sect1>
                <title>Liskov helyettesítés sértése</title>
                <para>Írjunk olyan OO, leforduló Java és C++ kódcsipetet, amely megsérti a Liskov elvet! Mutassunk rá a
                    megoldásra: jobb OO tervezés.</para>
                <para>C++ kódcsipet amelz megsérti a Liskov elvet: </para>
                <programlisting>// ez a T az LSP-ben
class Madar {
public:
     virtual void repul() {};
};

// ez a két osztály alkotja a "P programot" az LPS-ben
class Program {
public:
     void fgv ( Madar &amp;madar ) {
          madar.repul();
     }
};

// itt jönnek az LSP-s S osztályok
class Sas : public Madar
{};

class Pingvin : public Madar // ezt úgy is lehet/kell olvasni, hogy a pingvin tud repülni
{};

int main ( int argc, char **argv )
{
     Program program;
     Madar madar;
     program.fgv ( madar );

     Sas sas;
     program.fgv ( sas );

     Pingvin pingvin;
     program.fgv ( pingvin ); // sérül az LSP, mert a P::fgv röptetné a Pingvint, ami ugye lehetetlen.

}</programlisting>
                 <para>Így lenne helyes:</para>
                <programlisting>// ez a T az LSP-ben
class Madar {
//public:
//  void repul(){};
};

// ez a két osztály alkotja a "P programot" az LPS-ben
class Program {
public:
     void fgv ( Madar &amp;madar ) {
          // madar.repul(); a madár már nem tud repülni
          // s hiába lesz a leszármazott típusoknak
          // repül metódusa, azt a Madar&amp; madar-ra úgysem lehet hívni
     }
};

// itt jönnek az LSP-s S osztályok
class RepuloMadar : public Madar {
public:
     virtual void repul() {};
};

class Sas : public RepuloMadar
{};

class Pingvin : public Madar // ezt úgy is lehet/kell olvasni, hogy a pingvin tud repülni
{};

int main ( int argc, char **argv )
{
     Program program;
     Madar madar;
     program.fgv ( madar );

     Sas sas;
     program.fgv ( sas );

     Pingvin pingvin;
     program.fgv ( pingvin );

}

</programlisting>
            </sect1>
            <sect1>
                <title>Szülo-gyerek</title>
                <para>Írjunk Szülő-gyerek Java és C++ osztálydefiníciót, amelyben demonstrálni tudjuk, hogy az ősön
                    keresztül csak az ős üzenetei küldhetőek!
                </para>
                <para>Ez a feladat csupán azt demonstrálná, hogy nem lehetséges egy adott szülo referencián keresztül, ami egy ˝
                    gyerek objektumára hivatkozik, meghívni gyermeke egy olyan metódusát amit o maga nem definiált. </para>
                <para>A nem Osök által definiált metódusokhoz nem férhetünk hozzá, hacsak nem ˝ downcastoljuk az adott objektumot a tényleges típusára. 
                    Ez esetben viszont megsértjük az eloz˝ o feladatban ismertetett Liskov-elvet. </para>
                <para>C++-ban:</para>
                <programlisting>#include &lt;iostream>
#include &lt;string>
class Parent
{
public:
    void saySomething()
    {
    std::cout &lt;&lt; "Parent says: BLA BLA BLA\n";
    }
};
class Child : public Parent
{
public:
    void echoSomething(std::string msg)
    {
    std::cout &lt;&lt; msg &lt;&lt; "\n";
    }
};
class App
{
    int main()
    {
        Parent* p = new Parent();
        Parent* p2 = new Child();
        std::cout &lt;&lt; "Invoking method of parent\n";
        p->saySomething();
        std::cout &lt;&lt; "Invoking method of child through parent ref\n";
        p2->echoSomething("This won’t work");
        delete p;
        delete p2;
    }
};
</programlisting>
                <para><inlinemediaobject>
                        <imageobject>
                            <imagedata fileref="kepek/szulo-gyerek-sert.png"/>
                        </imageobject>
                    </inlinemediaobject></para>
                <para>Javában:</para>
                <programlisting>class Parent
{
    public void saySomething()
    {
    System.out.println("Parent says: BLA BLA BLA");
    }
}
class Child extends Parent
{
    public void echoSomething(String msg)
    {
    System.out.println(msg);
    }
}
public class App
{
    public static void main(String[] args)
    {
        Parent p = new Parent();
        Parent p2 = new Child();
        System.out.println("Invoking method of parent");
        p.saySomething();
        System.out.println("Invoking method of child through parent ref");
        p2.echoSomething("This won’t work");
        }
}
</programlisting>
                <para><inlinemediaobject>
                        <imageobject>
                            <imagedata fileref="kepek/szulo-gyerek-sert2.png"/>
                        </imageobject>
                    </inlinemediaobject></para>
            </sect1>
            <sect1>
                <title>Hello, Android!</title>
                <para>Élesszük fel az SMNIST for Humans projektet!
                    <link>https://gitlab.com/nbatfai/smnist/tree/master/forHumans/SMNISTforHumansExp3/app/src/main</link>
                    Apró módosításokat eszközölj benne, pl. színvilág.</para>
                <para><inlinemediaobject>
                        <imageobject>
                            <imagedata fileref="kepek/SMINST.png"/>
                        </imageobject>
                    </inlinemediaobject></para>
                <para>Márcsak a színvilágot kell megváltoztatni a feladat szerint:
                    Ezt megtehetjük a SMNISTSurfaceView.java állományban a megfelelo˝
                    <itemizedlist>
                        <listitem>
                            <para>bgColor</para>
                        </listitem>
                        <listitem>
                            <para>textPaint</para>
                        </listitem>
                        <listitem>
                            <para>msgPaint</para>
                        </listitem>
                        <listitem>
                            <para>dotPaint</para>
                        </listitem>
                        <listitem>
                            <para>borderPaint</para>
                        </listitem>
                        <listitem>
                            <para>fillPaint</para>
                        </listitem>
                    </itemizedlist>
                    s a többi változók értékeinek megváltoztatásával.</para>
                <para><inlinemediaobject>
                        <imageobject>
                            <imagedata fileref="kepek/SMINST2.png"/>
                        </imageobject>
                    </inlinemediaobject></para>
            </sect1>
            
        </chapter>
    </part>
</book>
